#include <iostream>
#include <fstream>

// #include "FineFittingTracking.h"  // defunct and not needed anymore
#include "FineFittingTrackingLocalFrame.h"
#include "CorrespondSurfaceAndVolumetricTemplate.h"
#include "LinearFemDeformation.h"
#include "ElasticParameterOptimization.h"

#include "probePosReader.h"
#include "CommandLine.h"


#define ORG_SCALE 1

int main_tracking(CommandLine&, bool);
int main_param_estimation(CommandLine&);
void scaleMeshBy(TriangleMesh * mesh, double scaleFactor);

vector<int> compare_models(TriangleMesh * frameMesh, TriangleMesh * deformationMesh, char * outputFile);
//Add a constant amount of noise to some vertices
void addSaltAndPepperNoise();

//Methods to prepare artificial models by Jochen
int createVRML();
void computeError();
void computeIndices();
void enhanceTemplate();

int main(int argc, char **argv)
{
	if(argc <= 1)
	{
		cout<<"Missing input parameters."<<endl;
		return 0;
	}

	CommandLine cmd( argc, argv );

	switch( cmd.d_variant ) {
	case CommandLine::PARAM_ESTIMATE:
	  return main_param_estimation(cmd);
	  break;
	case CommandLine::TRACK:
	  return main_tracking(cmd,false);
	  break;
	case CommandLine::FEM_TRACK:
	  return main_tracking(cmd,true);
	  break;
	default:
	  //otherwise
	  cerr<<"Invalid first input parameter: should be either '-paramestimate' or '-track' or '-femtrack'."<<endl;
	  return 0;
	}
}


int main_param_estimation(CommandLine& cmd)
{
	int mode;
	vector<int> indexOfContactPoint;
	double contactRadius;
	bool moreFrames, lowResTetFile = true;
	float floatRead;
	char buffer[500], buffer2[500];

	//Parse input parameters:
	if ( cmd.d_path.size() == 0 ) {
	  cerr<<"Missing file name of initial configuration template model."<<endl;
	  return 0;
	}
	if ( cmd.d_filenames.size() == 0 ) {
	  cerr<<"Missing file name of deformed template model."<<endl;
	  return 0;
	}
	if ( cmd.d_contactFileName.size() == 0 ) {
	  cerr<<"Missing contact points file."<<endl;
	  return 0;
	}
	if ( cmd.d_forceFileName.size() == 0 ) {
	  cerr<<"Missing measured forces file."<<endl;
	  return 0;
	}
	if ( cmd.d_supportSurfFileName.size() == 0 ) {
		  cerr<<"Missing support surface file."<<endl;
		  return 0;
	}
	if ( cmd.d_solidmeshFileName.size() == 0 ) {
	  mode = 0;
	  cout<<"Solid mesh generated by tetgen."<<endl;
	} else {
	  mode = 1;
	}
	if ( cmd.d_lowResTetFile.size() == 0 ) {
	  cout<<"No low resolution tet mesh provided."<<endl;
	  lowResTetFile = false;
	}

	// read the initial configuration template:
	TriangleMesh * templateMesh = new TriangleMesh();
	importMeshWrapper( cmd.d_path.c_str(), templateMesh );

	// read the deforemed config meshes:
	FILE * fp = fopen(cmd.d_filenames.c_str(), "r");
	if(fp == NULL) moreFrames = false;
	else moreFrames = true;

	// read contact point from file
	double * contactPoint = new double[3];
	FILE * fpContact = fopen(cmd.d_contactFileName.c_str(), "r");
	for(int i = 0; i < 3; i++)
	{
		fscanf(fpContact, "%f ", &floatRead);
		contactPoint[i] = floatRead;
	}
	int nRead = fscanf(fpContact, "%f ", &floatRead);
	if(nRead == 1) contactRadius = floatRead;
	else contactRadius = 0;
	fclose(fpContact);

	//Add all points within some radius to the contact points
	//indexOfContactPoint = LinearFemDeformation::findClosestIndex(g_Vector(contactPoint[0], contactPoint[1], contactPoint[2]), templateMesh->nodes(), contactRadius);

	TriangleMesh * lowResMesh;
	if (lowResTetFile){
		lowResMesh = new TriangleMesh();
		importMeshWrapper(cmd.d_lowResTetFile, lowResMesh);
	}else
		lowResMesh = NULL;

	//Create the objects:
	TriangleMesh * frameMesh;
	g_Node * contactNode = new g_Node(g_Vector(contactPoint[0], contactPoint[1], contactPoint[2]));
	ElasticParameterOptimization * ElasParam =0;
	strcpy( buffer2, cmd.d_supportSurfFileName.c_str());
	if ( mode == 0 ) {
	  ElasParam  = new ElasticParameterOptimization(templateMesh, contactNode, contactRadius, lowResMesh, mode, buffer2, NULL);
	} else {
	  strcpy( buffer, cmd.d_solidmeshFileName.c_str());
	  ElasParam = new ElasticParameterOptimization(templateMesh, contactNode, contactRadius, lowResMesh, mode, buffer2, buffer);
	}
	strcpy( buffer, cmd.d_forceFileName.c_str());
	ElasParam->readForce(buffer);

	int numFrame = 0;

	while(moreFrames)
	{
	  if(fscanf(fp, "%s ", reinterpret_cast<char*>(&buffer)) == EOF)
		{
			moreFrames = false;
			continue;
		}

		frameMesh = new TriangleMesh();
		importMeshWrapper( buffer, frameMesh );

		ElasParam->computeDisplacement(frameMesh);
		ElasParam->computeElasticityParameters(numFrame, 100);

		numFrame++;
		delete frameMesh;

	}

	fclose(fp);

	delete templateMesh;
	delete ElasParam;
	delete [] contactPoint;

	return 1;
}


int main_tracking(CommandLine& cmd, bool withFEM)
{
	int i, numFrame, tTotal=0, tTracking=0, tFem=0, tHelp, tStart;
	vector<int> indexOfContactPoint;
	double scaleFactor, minX, maxX, minY, maxY, minZ, maxZ, contactRadius, sizeNbhd;
	bool withProbe = true, moreFrames, selfIntersect, femSimulationOk, lowResTetFile = true, withAnchorPoints = false;
	float floatRead;
	TriangleMesh * lowResMesh, * initialLowResMesh;
	char buffer[500];
	g_NodeContainer trackNodes, femNodes;

	cerr << "In tracking!" << endl;

	//Parse input parameters:
	if ( cmd.d_path.size() == 0 ) {
	  cerr<<"Missing file name of initial configuration template model."<<endl;
	  return 0;
	}
	if ( cmd.d_filenames.size() == 0 ) {
	  cerr<<"Missing file name of deformed template model."<<endl;
	  return 0;
	}
	if ( cmd.d_outputName.size() == 0 ) {
	  cerr<<"Missing output name."<<endl;
	  return 0;
	}
	if ( (cmd.d_contactFileName.size() == 0) && (cmd.d_probeFileName.size() == 0) ) {
	  cerr<<"Missing contact points file."<<endl;
	  return 0;
	}
	if ( (cmd.d_forceFileName.size() == 0) && (cmd.d_probeFileName.size() == 0) ) {
	  cerr<<"Missing measured forces file."<<endl;
	  return 0;
	}
	if ( cmd.d_lowResTetFile.size() == 0 ) {
	  cout<<"No low resolution tet mesh provided."<<endl;
	  lowResTetFile = false;
	}
	if ( cmd.d_markerFile.size() == 0 ) {
	  cout<<"No markers are provided."<<endl;
	}
	if ( cmd.d_probeFileName.size() == 0 ) {
	  withProbe = false;
	}
	if ( cmd.d_anchorPointsFile.size() > 0 ) {
	  withAnchorPoints = true;
	}

	// read the template:
	ifstream infile(cmd.d_path.c_str(), ios_base::in);
	if(infile.fail())
	{
		cout<<"Invalid file: "<<cmd.d_path<<endl;
		return 0;
	}
	TriangleMesh * templateMesh = new TriangleMesh();
	importMeshWrapper( cmd.d_path, templateMesh );


	// scale each mesh to the same size to make it easier to find good weights that work for all sequences:
	for(i = 0; i < (int)templateMesh->getNumberOfNodes(); i++)
	{
		if(i == 0)
		{
			minX = maxX = templateMesh->nodes()[i]->coordinate().x();
			minY = maxY = templateMesh->nodes()[i]->coordinate().y();
			minZ = maxZ = templateMesh->nodes()[i]->coordinate().z();
		}
		else
		{
			minX = min(minX, templateMesh->nodes()[i]->coordinate().x());
			maxX = max(maxX, templateMesh->nodes()[i]->coordinate().x());
			minY = min(minY, templateMesh->nodes()[i]->coordinate().y());
			maxY = max(maxY, templateMesh->nodes()[i]->coordinate().y());
			minZ = min(minZ, templateMesh->nodes()[i]->coordinate().z());
			maxZ = max(maxZ, templateMesh->nodes()[i]->coordinate().z());
		}
	}
	scaleFactor = 1.0 / sqrt(pow(maxX-minX, 2.0) + pow(maxY-minY, 2.0) + pow(maxZ-minZ, 2.0));
	cout<<scaleFactor<<endl;

	scaleMeshBy(templateMesh, scaleFactor);
	sprintf(buffer, "scaled_template_%s.wrl", cmd.d_outputName.c_str());
	exportMeshWrapper( buffer, templateMesh );

	// read the frames:
	FILE * fp = fopen(cmd.d_filenames.c_str(), "r");
	if(fp == NULL) moreFrames = false;
	else moreFrames = true;

	// read contact point from file
	double * contactPointAndForce = new double[6];
	vector<double> frameForce;//***

	std::vector<g_Vector> probePos;
	std::vector<g_Vector> probeOrient;
	std::vector<double> probeDepth;
	std::vector<g_Vector> probeForce;

	if (!withProbe) {

		// read contact point from file

		FILE * fpContact = fopen(cmd.d_contactFileName.c_str(), "r");
		for(i = 0; i < 6; i++)
		{
			fscanf(fpContact, "%f ", &floatRead);
			contactPointAndForce[i] = floatRead;
			if(i < 3) contactPointAndForce[i] = scaleFactor * contactPointAndForce[i];
		}
		i = fscanf(fpContact, "%f ", &floatRead);
		if(i == 1) contactRadius = scaleFactor * floatRead;
		else contactRadius = 0;
		fclose(fpContact);

		//read force per frame
		if (cmd.d_forceFileName.size()>0)//***
		{
		  FILE * fpForceFile = fopen(cmd.d_forceFileName.c_str(), "r");
		  while(fscanf(fpForceFile,"%s ",  reinterpret_cast<char*>(&buffer)) != EOF){
				float fx, fy, fz;
				FILE * fpForce = fopen(buffer, "r");
				fscanf(fpForce, "%f %f %f", &fx, &fy, &fz);
				frameForce.push_back(fx);frameForce.push_back(fy);frameForce.push_back(fz);
			}
		}
	} else {
		// new style of complete probe info
		ProbePosReader ppr( cmd.d_probeFileName );
		ppr.getPos(probePos);
		ppr.getOrient(probeOrient);
		ppr.getDepth(probeDepth);
		ppr.getForce(probeForce);
		std::vector<g_Vector>::reverse_iterator pFinalForce = probeForce.rbegin();
		contactPointAndForce[3] = pFinalForce->x();
		contactPointAndForce[4] = pFinalForce->y();
		contactPointAndForce[5] = pFinalForce->z();
		contactRadius = scaleFactor * ppr.getRadius();
		if (contactRadius < 0 ) {
			cerr << "Probe radius not defined!" << endl;
			contactRadius = 0.0;
		}
		// for legacy reasons copy first position
		contactPointAndForce[0] = scaleFactor * probePos[0].x() + probeOrient[0].x() * ppr.getRadius();
		contactPointAndForce[1] = scaleFactor * probePos[0].y() + probeOrient[0].y() * ppr.getRadius();
		contactPointAndForce[2] = scaleFactor * probePos[0].z() + probeOrient[0].z() * ppr.getRadius();
	}
	
	if ( withFEM ) {
	  //Add all points within some radius to the contact points
	  indexOfContactPoint = LinearFemDeformation::findClosestIndex(g_Vector(contactPointAndForce[0], contactPointAndForce[1], contactPointAndForce[2]),
								       templateMesh->nodes(), contactRadius);
	  double * allContactPointsAndForce = new double[6*indexOfContactPoint.size()];
	  for(i = 0; i < indexOfContactPoint.size(); i++) {
	    allContactPointsAndForce[6*i] = templateMesh->nodes()[indexOfContactPoint[i]]->coordinate().x();
	    allContactPointsAndForce[6*i+1] = templateMesh->nodes()[indexOfContactPoint[i]]->coordinate().y();
	    allContactPointsAndForce[6*i+2] = templateMesh->nodes()[indexOfContactPoint[i]]->coordinate().z();
	    if (cmd.d_forceFileName.size() > 0 ) {
	      allContactPointsAndForce[6*i+3] = frameForce[0];
	      allContactPointsAndForce[6*i+4] = frameForce[1];
	      allContactPointsAndForce[6*i+5] = frameForce[2];
	    }
	    else{
	      allContactPointsAndForce[6*i+3] = contactPointAndForce[3];
	      allContactPointsAndForce[6*i+4] = contactPointAndForce[4];
	      allContactPointsAndForce[6*i+5] = contactPointAndForce[5];
	    }
	  }
	delete [] contactPointAndForce;
	contactPointAndForce = allContactPointsAndForce;
	}
	//Create the objects:
	FineFittingTrackingLocalFrame tracker;
	TriangleMesh * deformedTemplate, * frameMesh;
	LinearFemDeformation * fem = NULL;

	numFrame = 0;

	cerr << "Setup complete" << endl;

	selfIntersect = false;
	while(moreFrames)
	{
		tStart = (int) time(0);

		if(fscanf(fp, "%s ",  reinterpret_cast<char*>(&buffer)) == EOF)
		{
			moreFrames = false;
			continue;
		}

		cout<<"Start frame "<<buffer<<endl;

		frameMesh = new TriangleMesh();

		if(cmd.d_useVrml)
		{
			//Read the mesh from a vrml file
			importMeshWrapper( buffer, frameMesh );
			frameMesh->calculateVertexNormals();
			//End read the mesh from a vrml file
		}
		else
		{
		        ifstream infileFrame(buffer, ios_base::in);
			//Read the mesh from an obj file with normal information
			vector<double> normalInformation;
			char buffer[100];
			double x, y, z;
			const unsigned int MAX_CHARS = 256; // Maximum number of characters on a comment line
			while(infileFrame.peek() != EOF)
			{
				if((infileFrame.peek() == '#') || (infileFrame.peek() == '\n'))
					infileFrame.ignore( MAX_CHARS, '\n' );
				if(infileFrame.peek() == 'v')
				{
					infileFrame >> buffer;
					infileFrame >> x;
					infileFrame >> y;
					infileFrame >> z;
					infileFrame.ignore( MAX_CHARS, '\n' );
					normalInformation.push_back(x);
					normalInformation.push_back(y);
					normalInformation.push_back(z);
					infileFrame >> buffer;
					infileFrame >> x;
					infileFrame >> y;
					infileFrame >> z;
					infileFrame.ignore( MAX_CHARS, '\n' );
					g_Node * node = new g_Node(g_Vector(x, y, z));
					frameMesh->node(node);
				}
				else infileFrame.ignore( MAX_CHARS, '\n' );
			}
			frameMesh->Normals_Resize();
			for(i = 0; i < frameMesh->getNumberOfNodes(); i++)
			{
				frameMesh->SetNormals(i, 0, normalInformation[3*i]);
				frameMesh->SetNormals(i, 1, normalInformation[3*i+1]);
				frameMesh->SetNormals(i, 2, normalInformation[3*i+2]);
			}
			infileFrame.close();
			//End read mesh from an obj file with normal information
		}

		if ( withAnchorPoints ) {
		  // add anchor points to frame mesh
		  TriangleMesh anchorMesh;
		  importMeshWrapper( cmd.d_anchorPointsFile, &anchorMesh );
		  anchorMesh.calculateVertexNormals();
		  // Loop over anchorMesh and add to frameMesh
		  g_NodeContainer anchorPts = anchorMesh.nodes();
		  int nCnt = frameMesh->getNumberOfNodes();
		  int aNCnt = 1; // 1-indexed
		  for (std::vector<g_Node*>::const_iterator pIter=anchorPts.begin(); pIter != anchorPts.end(); ++pIter ) {
		    frameMesh->node(new g_Node(**pIter));
		    // set normal at node with id
		    g_Vector normal = anchorMesh.getNormalAtNode(aNCnt);
		    frameMesh->SetNormals(nCnt, 0, normal.x());
		    frameMesh->SetNormals(nCnt, 1, normal.y());
		    frameMesh->SetNormals(nCnt, 2, normal.z());
		    ++nCnt; ++aNCnt;
		  }
		}

		scaleMeshBy(frameMesh, scaleFactor);
#ifdef USE_OFF_FILE
		sprintf(buffer, "scaled_frame_%d_%s.off", numFrame, cmd.d_outputName);
		std::ofstream ofScaledFrame(buffer);
		ofScaledFrame << "OFF\n" << frameMesh->getNumberOfNodes() << " 0 0\n";
		const g_NodeContainer& frameScaledNodes = frameMesh->nodes();
		for( g_NodeContainer::const_iterator nIt=frameScaledNodes.begin();
		     nIt != frameScaledNodes.end(); ++nIt ) {
		  ofScaledFrame << (*nIt)->coordinate() << std::endl;
		}
		ofScaledFrame.close();
#else
		std::ostringstream os;
		os << "scaled_frame_" << numFrame << "_" << cmd.d_outputName << ".wrl";
		TriangleMesh tmpMesh(*frameMesh);
		exportMeshWrapper(os.str(), &tmpMesh);
#endif
		if(numFrame == 0)
		{
			cerr << "Template mesh ... ";
			//First frame: set the template mesh
			tHelp = (int)time(0);
			tracker.SIZE_NBHD = sizeNbhd;
			tracker.setTemplate(templateMesh);
			tTracking = (int)time(0)-tHelp;
			tHelp = (int)time(0);

			if( withFEM ) {
			  if (lowResTetFile)
			    {
				initialLowResMesh = new TriangleMesh();
				importMeshWrapper(cmd.d_lowResTetFile, initialLowResMesh);
				scaleMeshBy(initialLowResMesh, scaleFactor);

				sprintf(buffer, "scaled_lowres_%d_%s.wrl", numFrame, cmd.d_outputName.c_str());
				exportMeshWrapper(buffer, initialLowResMesh);

				fem = new LinearFemDeformation(templateMesh, initialLowResMesh, "tet_mesh", 2);
			    }
			  else
			    {
			        lowResMesh = NULL;
					g_Node * contactNode = new g_Node(g_Vector(contactPointAndForce[0], contactPointAndForce[1], contactPointAndForce[2]));
				fem = new LinearFemDeformation(templateMesh, lowResMesh, "tet_mesh", 0, contactNode);
			    }

/*/START WITH A DIFFERENT FRAME
fem->setCoordinates("deformedTetMesh_frame_19.off");


deformedTemplate = new TriangleMesh();
importMeshWrapper( "neckKinect19.wrl", deformdTemplate );
tracker.resetTemplateCoo(deformedTemplate->nodes());

for(i = 0; i < indexOfContactPoint.size(); i++)
{
	contactPointAndForce[6*i] = deformedTemplate->nodes()[indexOfContactPoint[i]]->coordinate().x();
	contactPointAndForce[6*i + 1] = deformedTemplate->nodes()[indexOfContactPoint[i]]->coordinate().y();
	contactPointAndForce[6*i + 2] = deformedTemplate->nodes()[indexOfContactPoint[i]]->coordinate().z();
}

numFrame = 20;
//END WITH A DIFFERENT FRAME*/

			tFem = (int)time(0)-tHelp;
			} // end withFEM
		}
		else
		{
		  //Reset the template mesh
		  tHelp = (int)time(0);
		  tracker.resetTemplateCoo(deformedTemplate->nodes());
		  tTracking = (int)time(0)-tHelp;
		  if ( withFEM ) {
			tHelp = (int)time(0);
			if(!selfIntersect)
			{
				trackNodes = deformedTemplate->nodes();
				sprintf(buffer, "deformedTetMesh_frame_%d.off", numFrame);
				fem->updateCoordinates(&trackNodes, buffer);

				for(i = 0; i < indexOfContactPoint.size(); i++)
				{
					contactPointAndForce[6*i] = deformedTemplate->nodes()[indexOfContactPoint[i]]->coordinate().x();
					contactPointAndForce[6*i + 1] = deformedTemplate->nodes()[indexOfContactPoint[i]]->coordinate().y();
					contactPointAndForce[6*i + 2] = deformedTemplate->nodes()[indexOfContactPoint[i]]->coordinate().z();
					//apply current frame's force measuring
					if(cmd.d_forceFileName.size() > 0){//***
						contactPointAndForce[6*i+3] = frameForce[3*numFrame];
						contactPointAndForce[6*i+4] = frameForce[3*numFrame+1];
						contactPointAndForce[6*i+5] = frameForce[3*numFrame+2];
					} else {
						if (withProbe) {
							contactPointAndForce[6*i+3] = probeForce[numFrame].x();
							contactPointAndForce[6*i+4] = probeForce[numFrame].y();
							contactPointAndForce[6*i+5] = probeForce[numFrame].z();
						}
					}
				}
			}
			tFem = (int)time(0)-tHelp;
		  } // end withFEM
		}
		tHelp = (int)time(0);

		if ( withProbe ) {
#ifdef _DEBUG_MAIN_
			cerr << "Nodes: " << frameMesh->getNumberOfNodes() << endl;
			cerr << "Normals: " << endl;
			for ( int nCnt=0; nCnt<frameMesh->getNumberOfNodes(); nCnt+=10 ) {
			  cerr << nCnt << ": " << frameMesh->getNormalAtNode(nCnt+1) << endl;
			}
#endif
			cerr << "withProbe" << endl;
			g_Vector scaledProbePos = scaleFactor*probePos[numFrame];
			// For testing use
			// tracker.setFrame(frameMesh);
			tracker.setFrame(frameMesh,scaledProbePos, probeOrient[numFrame], scaleFactor*probeDepth[numFrame], contactRadius);
			if(numFrame == 0) {
					tracker.setProbeConstraint(scaledProbePos, probeOrient[numFrame]);
			}
		} else {
			tracker.setFrame(frameMesh);
		}

		if((numFrame == 0) && (cmd.d_markerFile.size() > 0) && (cmd.d_numMarkers > 0))
		{
			//First frame only: maybe use some markers:
		        strcpy( buffer, cmd.d_markerFile.c_str());
		        tracker.setMarkers(buffer, cmd.d_numMarkers, scaleFactor); //("C:\\Stefanie\\Projects\\Tracking\\Data\\neck\\landmark_file.txt", 18, scaleFactor);
			deformedTemplate = tracker.computeDeformedTemplate(NULL, true, NULL, true);
			tracker.resetTemplateCoo(deformedTemplate->nodes());
			tracker.unsetMarkers();

			sprintf(buffer, "alignment_markers_%s%d.wrl", cmd.d_outputName.c_str(), numFrame);
			exportMeshWrapper( buffer, deformedTemplate );
		}

		int tSetUp =(int)time(0);
		cout<<"Setup time: "<<numFrame<<" (s) "<<(tSetUp-tStart)<<endl;

		cerr << "Computing deformation" << endl;
#ifdef _DEBUG_MAIN_
		sprintf(buffer, "frame%s%d", cmd.d_outputName.c_str(), numFrame);
		if(numFrame == 0) deformedTemplate = tracker.computeDeformedTemplate(buffer, true);
		else deformedTemplate = tracker.computeDeformedTemplate(buffer, false);
#else
		if(numFrame == 0) deformedTemplate = tracker.computeDeformedTemplate(NULL, true);
		else deformedTemplate = tracker.computeDeformedTemplate(NULL, false);
#endif
		tTracking += (int)time(0)-tHelp;

		//Export the mesh after tracking
		sprintf(buffer, "tracking_%s%d.wrl", cmd.d_outputName.c_str(), numFrame);
		exportMeshWrapper( buffer, deformedTemplate );
		
		if ( withFEM ) {
		  tHelp = (int)time(0);
		  //Perform FEM to fix the unseen side of the mesh:
		  trackNodes = deformedTemplate->nodes();
		  fem->setNewPositions(trackNodes, tracker.getNearestNeighbors(true));
		  fem->setParameters(1000000, 0.45);
		  if(numFrame == 0) fem->setContactPtAndForce(contactPointAndForce, indexOfContactPoint.size());

		  try
		    {
		      femSimulationOk = fem->optimizeAndSimulate(false);
		    }
		  catch(char * exceptionString)
		    {
		      cout<<"Abandoning program "<<exceptionString<<endl;
		      return 0;
		    }
		  if(!femSimulationOk) cout<<"PROBLEM FEM->OPTIMIZEANDSIMULATE RETURNS FALSE"<<endl;

		  femNodes = fem->getUpdatedNodes();
		  for(i = 0; i < (int)trackNodes.numberOfItems(); i++)
		    trackNodes[i]->coordinate(femNodes[i]->coordinate());

		  tFem += (int)time(0)-tHelp;

		  //Export the mesh after FEM
		  sprintf(buffer, "fem_%s%d.wrl", cmd.d_outputName.c_str(), numFrame);
		  exportMeshWrapper( buffer, deformedTemplate );

		  //Allow tracker to adjust the transformations:
		  tracker.adjustTransformations(deformedTemplate, fem->getPredictedIndices());

		  //Export the final mesh
		  sprintf(buffer, "%s%d.wrl", cmd.d_outputName.c_str(), numFrame);
		  exportMeshWrapper( buffer, deformedTemplate );
		} // end withFEM

		tHelp = (int)time(0);
#if ORG_SCALE
		//Export the final mesh in the original scale
		if ( withFEM ) {
		  sprintf(buffer, "org_%s%d.wrl", cmd.d_outputName.c_str(), numFrame);
		} else {
		  sprintf(buffer, "tracking_org_%s%d.wrl", cmd.d_outputName.c_str(), numFrame);
		}
		TriangleMesh orgScaleMesh(*deformedTemplate);
		scaleMeshBy(&orgScaleMesh, 1.0F/scaleFactor);
		exportMeshWrapper( buffer, &orgScaleMesh );
#endif

#ifdef WITH_ERROR_FILE
		//Export the error
		sprintf(buffer, "errorFile_%s%d.txt", cmd.d_outputName.c_str(), numFrame);
		compare_models(frameMesh, deformedTemplate, buffer);
#endif
		sprintf(buffer, "trafos_%s%d.txt", cmd.d_outputName.c_str(), numFrame);
		tracker.exportTransformationParameters(buffer);
		int tPost = (int)time(0);
		cout<<"Post track time: "<<numFrame<<" (s) "<<(tPost-tHelp)<<endl;


		tTotal = (int)time(0) - tStart;

		cout<<"End frame "<<numFrame<<" Tracking (s) "<<tTracking<<" FEM (s) "<<tFem<<" Total (s) "<<tTotal<<endl;

		numFrame++;
		delete frameMesh;
	}

	fclose(fp);

	delete templateMesh;
	if (fem!=NULL) delete fem;
	if (contactPointAndForce) delete [] contactPointAndForce;

	return 1;
}

vector<int> compare_models(TriangleMesh * frameMesh, TriangleMesh * deformationMesh, char * outputFile)
{
	int i;
	double largestDist = 5.0 * deformationMesh->getMeshResolution();
	vector<double> distances;
	vector<int> validNeighbor;

	//Create a kd-tree on the frameMesh
	ANNpointArray		dataPts;
	ANNkd_tree*			kdTree;
	ANNpoint			queryPt;
	ANNidxArray			nnIdx;
	ANNdistArray		dists;

	dataPts = annAllocPts(frameMesh->getNumberOfNodes(), 3);
	queryPt = annAllocPt(3);
	nnIdx = new ANNidx[1];
	dists = new ANNdist[1];

	for(i = 0; i < frameMesh->getNumberOfNodes(); i++)
	{
	  dataPts[i][0] = frameMesh->nodes()[i]->coordinate().x();
	  dataPts[i][1] = frameMesh->nodes()[i]->coordinate().y();
	  dataPts[i][2] = frameMesh->nodes()[i]->coordinate().z();
	}
	kdTree = new ANNkd_tree(dataPts, frameMesh->getNumberOfNodes(), 3);

	//For each point on the deformationMesh with valid nearest neighbor, find the distance to its nearest neighbor
	deformationMesh->calculateVertexNormals();
	for(i = 0; i < deformationMesh->getNumberOfNodes(); i++)
	{
		queryPt[0] = deformationMesh->nodes()[i]->coordinate().x();
		queryPt[1] = deformationMesh->nodes()[i]->coordinate().y();
		queryPt[2] = deformationMesh->nodes()[i]->coordinate().z();

		kdTree->annkPriSearch(queryPt, 1, nnIdx, dists);
		if((deformationMesh->nodes()[i]->coordinate().DistanceTo(frameMesh->nodes()[nnIdx[0]]->coordinate()) < largestDist) &&
			(deformationMesh->getNormalAtNode(i+1).AngleBetween(frameMesh->getNormalAtNode(nnIdx[0]+1)) < MAX_ANGLE/180.0*3.14159))
		{
				if((frameMesh->nodes()[nnIdx[0]]->coordinate() - deformationMesh->nodes()[i]->coordinate()).Dot(deformationMesh->getNormalAtNode(i+1))> 0)
				{
					distances.push_back(sqrt(dists[0]));
					validNeighbor.push_back(1);
				}
				else
				{
					distances.push_back(-sqrt(dists[0]));
					validNeighbor.push_back(1);
				}
		}
		else
		{
			distances.push_back(largestDist);
			validNeighbor.push_back(-1);
		}
	}

	//Write the result to a file
	FILE * fp = fopen(outputFile, "w");
	for(i = 0; i < deformationMesh->getNumberOfNodes(); i++) fprintf(fp, "%f ", distances[i]);
	fclose(fp);

	//Free space
	delete kdTree;
	annDeallocPt(queryPt);
	annDeallocPts(dataPts);
	delete [] nnIdx;
	delete [] dists;
	annClose();

	return validNeighbor;
}

//Methods to prepare artificial models by Jochen
int createVRML()
{
	int numFile, fileNum;
	numFile = 25;

	char * path = "C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_nonLinear1\\gipshand_nonLinear1";
	char pathBuffer[200];

	for(fileNum = 0; fileNum < numFile; fileNum++)
	{
		if(fileNum < 10) sprintf(pathBuffer, "%s0%d.vtk", path, fileNum);
		else sprintf(pathBuffer, "%s%d.vtk", path, fileNum);
		ifstream infileVtkFile(pathBuffer);
		if(fileNum < 10) sprintf(pathBuffer, "%s0%d_front_enhanced.wrl", path, fileNum);
		else sprintf(pathBuffer, "%s%d_front_enhanced.wrl", path, fileNum);


		//Read the template
		TriangleMesh mesh;
		g_NodeContainer cont;
		importMeshWrapper( "C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_nonLinear1\\template_front_enhanced.wrl", &mesh );
		// infileTemplate.close();

		int i, j, numNodes, numNodesTet, bestId;
		double * x, * y, * z, dist, minDist;
		numNodes = mesh.getNumberOfNodes();

		//Read the coordinates and the displacements
		char buffer[100];

		do
		{
			infileVtkFile >> buffer;
		}while((strcmp(buffer, "POINTS") != 0) && (!infileVtkFile.eof()));

		infileVtkFile >> numNodesTet;
		infileVtkFile >> buffer;

		x = new double[numNodesTet];
		y = new double[numNodesTet];
		z = new double[numNodesTet];

		for(i = 0; i < numNodesTet; i++)
		{
			infileVtkFile >> x[0];
			infileVtkFile >> y[0];
			infileVtkFile >> z[0];
			g_Node * node = new g_Node(g_Vector(x[0], y[0], z[0]));
			cont.insert(node);
		}

		do
		{
			infileVtkFile >> buffer;
		}while ( ( strcmp( buffer, "VECTORS" ) != 0 ) && (!infileVtkFile.eof()));
		//Abort if the file is done
		if(infileVtkFile.eof())
			return 0;

		infileVtkFile >> buffer;
		infileVtkFile >> buffer;

		//Read the displacements
		for(i = 0; i < numNodesTet; i++)
		{
			infileVtkFile >> x[i];
			infileVtkFile >> y[i];
			infileVtkFile >> z[i];
		}

		//Change the coordinates
		for(i = 0; i < numNodes; i++)
		{
			//Find the node index in the tet mesh
			for(j = 0; j < numNodesTet; j++)
			{
				dist = mesh.nodes()[i]->coordinate().DistanceTo(cont[j]->coordinate());
				if((j == 0) || (dist < minDist))
				{
					bestId = j;
					minDist = dist;
				}
			}
			mesh.nodes()[i]->coordinate(mesh.nodes()[i]->coordinate() + g_Vector(x[bestId], y[bestId], z[bestId]));
		}

		infileVtkFile.close();
		delete [] x;
		delete [] y;
		delete [] z;

		//Export the file
		exportMeshWrapper( pathBuffer, &mesh );
	}

	return 1;
}

void computeIndices()
{
	std::set<int> frontIds, backIds;
	std::set<int>::iterator it;

	TriangleMesh complete;
	importMeshWrapper("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_linear\\template.wrl", &complete );
	TriangleMesh front;
	importMeshWrapper("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_linear\\template_front_enhanced.wrl", &front );

	int i, j, minId;
	double dist, minDist;

	for(i = 0; i < (int)front.getNumberOfNodes(); i++)
	{
		for(j = 0; j < (int)complete.getNumberOfNodes(); j++)
		{
			dist = front.nodes()[i]->coordinate().DistanceTo(complete.nodes()[j]->coordinate());
			if((j == 0) || (dist < minDist))
			{
				minDist = dist;
				minId = j;
			}
		}
		frontIds.insert(minId);
	}

	for(i = 0; i < (int)complete.getNumberOfNodes(); i++)
	{
		if(frontIds.find(i) == frontIds.end())
			backIds.insert(i);
	}

	FILE * fp = fopen("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_linear\\front_ids_enhanced.txt", "w");
	fprintf(fp, "%d\n", frontIds.size());
	for(it = frontIds.begin(); it != frontIds.end(); it++)
		fprintf(fp, "%d ", *it);
	fclose(fp);

	fp = fopen("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_linear\\back_ids_enhanced.txt", "w");
	fprintf(fp, "%d\n", backIds.size());
	for(it = backIds.begin(); it != backIds.end(); it++)
		fprintf(fp, "%d ", *it);
	fclose(fp);
}

void computeError()
{
	for(int numFrame = 0; numFrame < 13; numFrame++)
	{
		char buffer[200];

		if(2*numFrame < 10)
			sprintf(buffer, "C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_nonLinear1\\gipshand_nonLinear10%d.wrl", 2*numFrame);
		else
			sprintf(buffer, "C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_nonLinear1\\gipshand_nonLinear1%d.wrl", 2*numFrame);

		TriangleMesh groundTruth;
		importMeshWrapper(buffer,&groundTruth);

		sprintf(buffer, "C:\\Stefanie\\Projects\\Tracking\\Results\\ResultsHand\\nonLinear1\\Tracking alpha=30\\tracking_hand%d.wrl", numFrame);
		TriangleMesh mesh;
		importMeshWrapper(buffer,&mesh);

		FILE * fp = fopen("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\gipshand_nonLinear1\\back_ids_enhanced.txt", "r");
		int i, j, intRead, numIds, numVertices;
		std::vector<int> ids;
		fscanf(fp, "%d ", &numIds);
		for(i = 0; i < numIds; i++)
		{
			fscanf(fp, "%d ", &intRead);
			//Use this to measure the error in the area of the deforming finger only for the hand model
			//if((groundTruth.nodes()[intRead]->coordinate().y() > 40) &&
			//((groundTruth.nodes()[intRead]->coordinate().z() < 0) && (groundTruth.nodes()[intRead]->coordinate().z() > -30)))
			ids.push_back(intRead);
		}
		fclose(fp);

		double average, max, dist;
		average = 0;

		numVertices = groundTruth.getNumberOfNodes();

		for(i = 0; i < (int)ids.size(); i++)
		{
			dist = mesh.nodes()[ids[i]]->coordinate().DistanceTo(groundTruth.nodes()[ids[i]]->coordinate());

			for(j = 0; j < numVertices; j++)
				dist = min(dist, mesh.nodes()[ids[i]]->coordinate().DistanceTo(groundTruth.nodes()[j]->coordinate()));

			average += dist;
			if((i == 0) || (dist > max)) max = dist;
		}
		average = average / (double)ids.size();

		printf("%.2f \& %.2f\n", average, max);
	}
}

void addSaltAndPepperNoise()
{
	//Load the model
	TriangleMesh mesh;
	importMeshWrapper("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\buste_linear\\buste_linear09_front.wrl", &mesh );

	//Add a random amount of noise with constant probability
	srand ( time(NULL) );

	int i, random;
	double resolution, offset;
	resolution = mesh.getMeshResolution();
	g_Vector viewpoint(5.0, 107.0, 250.0);
	g_Vector offsetVec;

	for(i = 0; i < (int)mesh.getNumberOfNodes(); i++)
	{
		if((rand() % 50) == 0)
		{
			random = rand() % 50;
			offset = -resolution + random * 0.1 * resolution;
			offsetVec = viewpoint-mesh.nodes()[i]->coordinate();
			offsetVec.Normalize();
			mesh.nodes()[i]->coordinate(mesh.nodes()[i]->coordinate() + offset * offsetVec);
		}
	}

	//Export the model
	exportMeshWrapper( "C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\buste_linear\\buste_linear09_front_outliers.wrl", &mesh );
}

void enhanceTemplate()
{
	TriangleMesh fullTemplate;
	importMeshWrapper("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\square_linear\\template.wrl", &fullTemplate);

	TriangleMesh lastFrame;
	importMeshWrapper("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\square_linear\\square_linear24.wrl", &lastFrame );

	TriangleMesh partTemplate;
	importMeshWrapper("C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\square_linear\\template_front.wrl", &partTemplate);

	int i, j, numElements, numPartElements, numNodes, id1, id2, id3, elemId;
	double threshold = 0.0000001;
	g_Node * newNode;
	g_Element * newElement;

	numElements = fullTemplate.getNumberOfTriangles();
	numPartElements = partTemplate.getNumberOfTriangles();
	numNodes = partTemplate.getNumberOfNodes();

	for(i = 0; i < numElements; i++)
	{
		//Check for elements that were "glued" during Jochen's FEM prediction:
		if((fullTemplate.elements()[i]->nodes()[0]->coordinate().DistanceTo(lastFrame.elements()[i]->nodes()[0]->coordinate()) < threshold) &&
			(fullTemplate.elements()[i]->nodes()[1]->coordinate().DistanceTo(lastFrame.elements()[i]->nodes()[1]->coordinate()) < threshold) &&
			(fullTemplate.elements()[i]->nodes()[2]->coordinate().DistanceTo(lastFrame.elements()[i]->nodes()[2]->coordinate()) < threshold))
		{
			//Check if this element is already in the template
			id1 = -1;
			for(j = 0; j < numNodes; j++)
			{
				if(fullTemplate.elements()[i]->nodes()[0]->coordinate().DistanceTo(partTemplate.nodes()[j]->coordinate()) < threshold)
				{
					id1 = j;
					break;
				}
			}

			id2 = -1;
			for(j = 0; j < numNodes; j++)
			{
				if(fullTemplate.elements()[i]->nodes()[1]->coordinate().DistanceTo(partTemplate.nodes()[j]->coordinate()) < threshold)
				{
					id2 = j;
					break;
				}
			}

			id3 = -1;
			for(j = 0; j < numNodes; j++)
			{
				if(fullTemplate.elements()[i]->nodes()[2]->coordinate().DistanceTo(partTemplate.nodes()[j]->coordinate()) < threshold)
				{
					id3 = j;
					break;
				}
			}

			elemId = -1;
			if((id1 != -1) && (id2 != -1) && (id3 != -1))
			{
				for(j = 0; j < numPartElements; j++)
				{
					if(((partTemplate.elements()[j]->nodes()[0]->id() == id1+1) || (partTemplate.elements()[j]->nodes()[0]->id() == id2+1) || (partTemplate.elements()[j]->nodes()[0]->id() == id3+1)) &&
						((partTemplate.elements()[j]->nodes()[1]->id() == id1+1) || (partTemplate.elements()[j]->nodes()[1]->id() == id2+1) || (partTemplate.elements()[j]->nodes()[1]->id() == id3+1)) &&
						((partTemplate.elements()[j]->nodes()[2]->id() == id1+1) || (partTemplate.elements()[j]->nodes()[2]->id() == id2+1) || (partTemplate.elements()[j]->nodes()[2]->id() == id3+1)))
					{
						elemId = j;
						break;
					}
				}
			}

			//If not: add it:
			if(elemId == -1)
			{
				newElement = new g_Element();
				if(id1 == -1)
				{
					newNode = new g_Node(fullTemplate.elements()[i]->nodes()[0]->coordinate());
					partTemplate.node(newNode);
				}
				else newNode = partTemplate.nodes()[id1];
				newElement->node(newNode);

				if(id2 == -1)
				{
					newNode = new g_Node(fullTemplate.elements()[i]->nodes()[1]->coordinate());
					partTemplate.node(newNode);
				}
				else newNode = partTemplate.nodes()[id2];
				newElement->node(newNode);

				if(id3 == -1)
				{
					newNode = new g_Node(fullTemplate.elements()[i]->nodes()[2]->coordinate());
					partTemplate.node(newNode);
				}
				else newNode = partTemplate.nodes()[id3];
				newElement->node(newNode);

				partTemplate.element(newElement);

				numNodes = partTemplate.getNumberOfNodes();
			}
		}
	}

	exportMeshWrapper( "C:\\Stefanie\\Projects\\Tracking\\Data\\GroundTruthDataSets\\square_linear\\template_front_enhanced.wrl", &partTemplate );
}

void scaleMeshBy(TriangleMesh * mesh, double scaleFactor)
{
  const g_NodeContainer& mNodes = mesh->nodes();
  // const is ok here because we don't change the pointer -- pointers are evil :-)
  for ( g_NodeContainer::const_iterator nIt = mNodes.begin();
	nIt != mNodes.end(); ++nIt ) {
    (*nIt)->coordinate(scaleFactor * (*nIt)->coordinate());
  }
  return;
}

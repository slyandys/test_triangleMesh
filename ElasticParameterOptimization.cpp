#include "ElasticParameterOptimization.h"
#include "LinearFemDeformation.h"

#include "asa047.hpp"

#include <iostream>
#include <fstream>

#define _USE_MATH_DEFINES
#include <cmath>

#define USE_NONLINEAR_OPT

ElasticParameterOptimization* g_epo;

extern "C" double wrapFunctor( double* lame ) {
  static ElasticParameterOptimization::NLMinimization epo_nlm( g_epo );
  return (epo_nlm)(lame);
}


void ElasticParameterOptimization::InitMeshfromFile( char * solidmeshFileName)
{
	
	char buf[512];
	FILE * fp;
	string* s = new string();
	int n1,n2,n3,n4;
	float x,y,z;

	if(solidmeshFileName != NULL)
		sprintf(buf, solidmeshFileName);
	else
		//sprintf(buf, "C:\\MTekieh\\ITK\\data\\foam\\simulation\\foamblock\\linear_foamblock_linear00.vtk");//old series
		sprintf(buf, "C:\\MTekieh\\ITK\\data\\foam\\simulation\\foamblock2\\foamblock_linear24.vtk");//new series
	
	fp = fopen(buf, "r");
	//read the initial positions
	fscanf(fp, "%s %s %s %s %s/n", s, s, s, s, s);
	fscanf(fp, "%s %s %s\n", s, s, s);
	fscanf(fp, "%s\n", s);
	fscanf(fp, "%s %s\n", s, s);
	fscanf(fp, "%s %d %s\n",  s, &numNodes, s);
		
	//Store the tetrahedral mesh: nodes
	allNodes.clear();
	for(int i = 0; i < numNodes; i++){
		fscanf(fp, "%f %f %f\n", &x, &y, &z);
		g_Node * newNode = new g_Node(g_Vector(x, y, z)); 
		allNodes.insert(newNode);
	}

	fscanf(fp, "\n%s %d %s\n",  s, &numTetrahedra, s);
	//Tetrahedra:
	allTetrahedra.clear();
	for(int i = 0; i < numTetrahedra; i++)
	{
	fscanf(fp, "%d %d %d %d %d\n",  &n1, &n1, &n2, &n3, &n4);
	vector<int> tetrahedron;
	tetrahedron.push_back(n1);
	tetrahedron.push_back(n2);
	tetrahedron.push_back(n3);
	tetrahedron.push_back(n4);

	allTetrahedra.push_back(tetrahedron);
	}
		
	fclose(fp);
	
}

void ElasticParameterOptimization::print(double * matrix, int m, int n, char * filename)
{
	FILE * fp = fopen(filename,"w");

	//this is for column major stored matrix
	for(int j = 0; j < m; j++){
		for (int i = 0; i < n; i++){
			fprintf(fp, "%f ", matrix[i*m+j]);
			if((i+1)%3 == 0)
				fprintf(fp, "   ");
		}

		fprintf(fp, "\n");
		/*if((j+1)%3 == 0)
				fprintf(fp, "\n");*/
	}
	fclose(fp);
}

void ElasticParameterOptimization::printParameters(char * filename)
{
	FILE * fp;
	if(filename == NULL)
		fp = fopen("ElasticityParameters.txt","w");
	else
		fp = fopen(filename,"w");

	fprintf(fp, "%s\n\n", "# Lambda   Mu   Overall_Error   Overall_Displacement_Error   Overall_Force_Error   Residual");
	for (int i = 0; i < lambda.size(); i++){
		fprintf(fp, "%2.10f    ", lambda[i]);
		fprintf(fp, "%2.10f    ", mu[i]);
		fprintf(fp, "%2.10f    ", overallError[i]);
		fprintf(fp, "%2.10f    ", overallErrorDisp[i]);
		fprintf(fp, "%2.10f    ", overallErrorForce[i]);
		if(residualsqrt.size() == lambda.size()) fprintf(fp, "%2.10f", residualsqrt[i]);
		fprintf(fp, "\n");
	}

	fclose(fp);
}

void ElasticParameterOptimization::exportSolidMesh(char * filename, double* Qout )
{
	FILE * fp = fopen(filename,"w");

	fprintf(fp, "%s\n%s\n%s\n%s\n", "# vtk DataFile Version 2.0", "Generated by tetgen", "ASCII", "DATASET UNSTRUCTURED_GRID");
	fprintf(fp, "%s %d %s\n","POINTS", numNodes, "float");
	for(int i = 0; i < numNodes; i++){
		fprintf(fp, "%f %f %f\n", allNodes[i]->coordinate().x(), allNodes[i]->coordinate().y(), allNodes[i]->coordinate().z());
	}
	
	fprintf(fp, "\n%s %d %d\n", "CELLS", numTetrahedra, 5*numTetrahedra);
	for(int i = 0; i < numTetrahedra; i++){
		fprintf(fp, "%d %d %d %d %d\n", allTetrahedra[i].size(), allTetrahedra[i][0], allTetrahedra[i][1], allTetrahedra[i][2], allTetrahedra[i][3]);
	}
	
	fprintf(fp, "\n%s %d\n", "CELL_TYPES", numTetrahedra);
	for(int i = 0; i < numTetrahedra; i++){
		fprintf(fp, "10\n");
	}
	fprintf(fp, "\n%s %d\n", "POINT_DATA", numNodes);


	if ( Qout != NULL ) {
	  fprintf(fp, "\n\n%s\n", "VECTORS displacement float");
	  for(int i = 0; i < numNodes; i++)
	    fprintf(fp, "%f %f %f ", Qout[3*i], Qout[3*i+1], Qout[3*i+2]);
	} else if(Q != NULL) {
	  fprintf(fp, "\n\n%s\n", "VECTORS displacement float");
	  for(int i = 0; i < numNodes; i++)
	    fprintf(fp, "%f %f %f ", Q[3*i], Q[3*i+1], Q[3*i+2]);
	}

	if(F != NULL){
		fprintf(fp, "\n\n%s\n", "VECTORS force float");
		for(int i = 0; i < numNodes; i++)
			fprintf(fp, "%f %f %f ", F[3*i], F[3*i+1], F[3*i+2]);
	}

	if(nodeError != NULL){
		fprintf(fp, "\n\n%s\n", "VECTORS error_Node float");
		for(int i = 0; i < numNodes; i++)
			fprintf(fp, "%f %f %f ", nodeError[3*i], nodeError[3*i+1], nodeError[3*i+2]);
	}

	if(normalError != NULL){
		fprintf(fp, "\n\n%s\n", "VECTORS error_Normal float");
		for(int i = 0; i < numNodes; i++)
			fprintf(fp, "%f %f %f ", normalError[3*i], normalError[3*i+1], normalError[3*i+2]);
	}

	fclose(fp);
}




ElasticParameterOptimization::ElasticParameterOptimization()
{
	templateMesh = NULL;
	frameMesh = NULL;
	matrixK = NULL;
	Q = NULL;
	F = NULL;
	nodeError = NULL;
	normalError = NULL;
	lowResMesh = NULL;
	linLameOpt = NULL;
	nonlinLameOpt = NULL;
	lameResult = NULL;
	numContactPoints = 0;
	allNodes.clear();
	allTetrahedra.clear();
	trianglesOnSurface.clear();
	//mapTet2SurfID.clear();
	mapStartIndices.clear();
	supportSurfNodes.clear();
	freeSurfNodes.clear();
	
}

ElasticParameterOptimization::ElasticParameterOptimization(TriangleMesh * inMesh,  g_Node * contactPoint, double cRadius, TriangleMesh * lresMesh, int mode, char * supportSurfFileName, char * solidmeshFileName)
{
	templateMesh = NULL;
	frameMesh = NULL;
	matrixK = NULL;
	Q = NULL;
	F = NULL;
	nodeError = NULL;
	normalError = NULL;
	lowResMesh = NULL;
	linLameOpt = NULL;
	nonlinLameOpt = NULL;
	lameResult = NULL;
	numContactPoints = 0;
	allNodes.clear();
	allTetrahedra.clear();
	trianglesOnSurface.clear();
	//mapTet2SurfID.clear();
	mapStartIndices.clear();
	supportSurfNodes.clear();
	freeSurfNodes.clear();

	contactRadius = cRadius;
	templateMesh = inMesh;
	
	if(mode == 0){
		
		//Simplify the mesh: 	
		if(lresMesh == NULL){
			lowResMesh = lresMesh; // assigns NULL intentionally
			std::cerr << "Calling intersectionTetgen"<< std::endl; 
			if(intersectionTetgen(inMesh, lowResMesh))
			{
				cout<<"Problem simplifying mesh"<<endl;
				return;
			}
		}
		else lowResMesh = new TriangleMesh(*lresMesh);



		//Compute tetrahedralization of the mesh
		int i, j, numTriangles;
		bool found;

		//Compute tetrahedralization of the mesh

		tetgenio * in, * out;
		in = NULL;
		createTetgenMesh(in, lowResMesh);
		out = new tetgenio();

		// Tetrahedralize the PLC. Switches are chosen to read a PLC (p)
		tetgenbehavior b;

		b.parse_commandline(ARG); 
		tetrahedralize(&b, in, out);

		//Copy the information to the class variables:
		numNodes = out->numberofpoints;
		numTetrahedra = out->numberoftetrahedra;

		//Store the tetrahedral mesh: nodes (allNodes contains the initial configuration positions)
		allNodes.clear();
		for(i = 0; i < numNodes; i++)
		{
			g_Node * newNode = new g_Node(g_Vector(out->pointlist[3*i], out->pointlist[3*i+1], out->pointlist[3*i+2])); 
			allNodes.insert(newNode);
		}
	
		//Tetrahedra:
		allTetrahedra.clear();
		for(i = 0; i < numTetrahedra; i++)
		{
			vector<int> tetrahedron;
			tetrahedron.push_back(out->tetrahedronlist[4*i]-1);
			tetrahedron.push_back(out->tetrahedronlist[4*i+1]-1);
			tetrahedron.push_back(out->tetrahedronlist[4*i+2]-1);
			tetrahedron.push_back(out->tetrahedronlist[4*i+3]-1);

			allTetrahedra.push_back(tetrahedron);
		}

		delete in;
		delete out;


	}else if(mode == 1){

		InitMeshfromFile(solidmeshFileName);

	}

	//export tetgen mesh
	exportSolidMesh("SolidMeshUndeformed.vtk");


	//set the support surface nodes
	setSupportSurfaceNodes(supportSurfFileName);
	



	//Compute and store the matching information:
	CorrespondTemplates * corres = new CorrespondTemplates();
	corres->setAlignedSurface(inMesh);
	corres->setTetModel(allNodes, allTetrahedra);
	corres->computeMappings( NULL,NULL, contactPoint);
	vector<int> mapTet2SurfID = corres->getMapTet2SurfID();
	//maps tetmesh to surface mesh
	mapStartIndices = corres->getMappingIndicesTet();
	mapStartWeights = corres->getMappingWeightsTet();
	mapStartOffsets = corres->getMappingOffsetsTet();
	//set the contact points(we know the actual contact point, should find the nearest triangle in tetmesh)
	contactNodes = corres->getContactPoints();
	contactWeights = corres->getContactWeights();
	contactOffset = corres->getContactOffset();
	numContactPoints = contactNodes.size();
	trianglesOnSurface = corres->getTriOnSurf();
		


#ifdef _USE_SINGLE_CONTACT_
	cerr << "-------------------------" << endl;
	cerr << "Number of contact points: " << numContactPoints << endl;
	cerr << "-------------------------" << endl;
	double maxWeight = -1.0; int maxI = -1;
	for (int i=0; i<numContactPoints; ++i ) {
	  if ( contactWeights[i] > maxWeight ) { 
	    maxWeight = contactWeights[i];
	    maxI = i;
	  }
	  cerr << contactNodes[i] << ": " << contactWeights[i] << " Offset: " << contactOffset[i] << endl;
	}
	if ( maxI >= 0 ) {
	  int maxNode = contactNodes[maxI]; 
	  contactNodes.clear();
	  contactNodes.push_back( maxNode );
	  contactWeights.clear();
	  contactWeights.push_back(1.0);
	  double maxOffset = contactOffset[maxI];
	  contactOffset.clear();
	  contactOffset.push_back( maxOffset );
	  numContactPoints = 1;
	}
#endif


	delete corres;


	//calculate the contact  area
	computeContactArea();


	//set the surface and interior nodes
		for(int i = 0; i < numNodes; i++){
		if(mapStartIndices[3*i] == -1)
			interNodes.push_back(i);
			
		else if(ISContactNode(i) == -1 && supportSurfNodes[i] == -1)//free surface node
			freeSurfNodes.push_back(i);
	}

	numInterNodes = interNodes.size();
	numSurfNodes = numNodes - numInterNodes;
	numFreeSNodes = numSurfNodes - (numSuppNodes + numContactPoints);             
	
	
	cout<<"Contact Points: "<<contactNodes[0]<<" "<<contactNodes[1]<<" "<<contactNodes[2]<<endl;
	//while(!cin.get());

}
	
ElasticParameterOptimization::~ElasticParameterOptimization()
{
	if(matrixK != NULL)
	{
		delete [] matrixK;
		matrixK = NULL;
	}
	if(Q != NULL)
	{
		delete [] Q;
		Q = NULL;
	}
	if(F != NULL)
	{
		delete [] F;
		F = NULL;
	}
	
	if(lowResMesh != NULL) 
	{
		delete lowResMesh;
		lowResMesh = NULL;
	}
	if(lameResult != NULL) 
	{
		delete lameResult;
		lameResult = NULL;
	}
	int i, numNodes;
	numNodes = allNodes.numberOfItems();
	for(i = 0; i < numNodes; i++)
		delete allNodes[i];
	allNodes.clear();
}




bool ElasticParameterOptimization::intersectionTetgen(TriangleMesh * inMesh, TriangleMesh *& tempMesh)
{
	int i, numNodes, numTriangles;
	bool returnVal;

	//Simplify the mesh: 

		//Case 1: Use MeshSimplification class (explicitly disallow self-intersections)
		if(tempMesh != NULL) delete tempMesh;

		MeshSimplification simplify(inMesh);
//		simplify.useVolumeCost();
		tempMesh = new TriangleMesh(*(simplify.getSimplifiedMesh(SIMPLIFIED_NUM, true)));
		exportMeshWrapper( "lowRes.wrl", tempMesh ); 

	//Compute tetrahedralization of the mesh
	tetgenio * in, * out;
	in = NULL;
	createTetgenMesh(in, tempMesh);
	out = new tetgenio();

	// Check for intersections
	tetgenbehavior b;
	b.parse_commandline("dQ");
	tetrahedralize(&b, in, out);
	
	//In -d mode, points are only reported if there are self-intersections
	if(out->numberofpoints > 0) returnVal = true;
	else
	{
		//Reset the meshes (just in case tetgen changes anything here)
		createTetgenMesh(in, tempMesh);
		delete out;
		out = new tetgenio();

		tetgenbehavior bOther;
		bOther.parse_commandline(ARG_Q);
		tetrahedralize(&bOther, in, out);

		if(out->numberofpoints > MAX_NUM_VERT_IN_TET) returnVal = true;
		else returnVal = false;
	}

	delete in;
	delete out;

	return returnVal;
}

void ElasticParameterOptimization::createTetgenMesh(tetgenio *& in, TriangleMesh * tempMesh)
{
	int i, numVertices, numTriangles;
	tetgenio::facet *f;
	tetgenio::polygon *p;

	if(in != NULL) delete in;
	in = new tetgenio();

	// All indices start from 1.
	in->firstnumber = 1;

	numVertices = tempMesh->getNumberOfNodes();
	numTriangles = tempMesh->getNumberOfTriangles();

	// Vertices
	in->numberofpoints = numVertices;
	in->pointlist = new REAL[numVertices * 3];
	for(i = 0; i < numVertices; i++)
	{
		in->pointlist[3*i] = tempMesh->nodes()[i]->coordinate().x(); 
		in->pointlist[3*i+1] = tempMesh->nodes()[i]->coordinate().y(); 
		in->pointlist[3*i+2] = tempMesh->nodes()[i]->coordinate().z(); 
	}

	// Triangles
	in->numberoffacets = numTriangles;
	in->facetlist = new tetgenio::facet[numTriangles];
	in->facetmarkerlist = new int[numTriangles];
	for(i = 0; i < numTriangles; i++)
	{
		f = &in->facetlist[i];
		f->numberofpolygons = 1;
		f->polygonlist = new tetgenio::polygon[f->numberofpolygons];
		f->numberofholes = 0;
		f->holelist = NULL;
		p = &f->polygonlist[0];
		p->numberofvertices = 3;
		p->vertexlist = new int[p->numberofvertices];
		p->vertexlist[0] = tempMesh->elements()[i]->nodes()[0]->id();
		p->vertexlist[1] = tempMesh->elements()[i]->nodes()[1]->id();
		p->vertexlist[2] = tempMesh->elements()[i]->nodes()[2]->id();
		in->facetmarkerlist[i] = 0;
	}
}




void ElasticParameterOptimization::computeMatrixK(double youngsModulus, double poissonRatio, int derivative)
{
	int i, j, k, mappedJ, mappedK;

	if((allNodes.numberOfItems() == 0) || (allTetrahedra.size() == 0)) return;
	if(youngsModulus < 0 && derivative != -2) return;
	if(((poissonRatio < 0) || (poissonRatio >= 0.5)) && derivative != -2) return;

	if(matrixK == NULL) matrixK = new double[3*numNodes * 3*numNodes];
	for(i = 0; i < 3*numNodes * 3*numNodes; i++) matrixK[i] = 0;
	double * localK = new double[12*12];
	for(i = 0; i < allTetrahedra.size(); i++)
	{
		computeLocalMatrixK(localK, i, youngsModulus, poissonRatio, derivative);
		for(j = 0; j < 4; j++)
		{
			mappedJ = allTetrahedra[i][j];
			for(k = 0; k < 4; k++)
			{
				mappedK = allTetrahedra[i][k];

				matrixK[(3*mappedK)*3*numNodes + (3*mappedJ)] += localK[(3*k)*12 + (3*j)];
				matrixK[(3*mappedK)*3*numNodes + (3*mappedJ+1)] += localK[(3*k)*12 + (3*j+1)];
				matrixK[(3*mappedK)*3*numNodes + (3*mappedJ+2)] += localK[(3*k)*12 + (3*j+2)];
				
				matrixK[(3*mappedK+1)*3*numNodes + (3*mappedJ)] += localK[(3*k+1)*12 + (3*j)];
				matrixK[(3*mappedK+1)*3*numNodes + (3*mappedJ+1)] += localK[(3*k+1)*12 + (3*j+1)];
				matrixK[(3*mappedK+1)*3*numNodes + (3*mappedJ+2)] += localK[(3*k+1)*12 + (3*j+2)];
				
				matrixK[(3*mappedK+2)*3*numNodes + (3*mappedJ)] += localK[(3*k+2)*12 + (3*j)];
				matrixK[(3*mappedK+2)*3*numNodes + (3*mappedJ+1)] += localK[(3*k+2)*12 + (3*j+1)];
				matrixK[(3*mappedK+2)*3*numNodes + (3*mappedJ+2)] += localK[(3*k+2)*12 + (3*j+2)];
			}
		}
	}
	delete [] localK;
}

void ElasticParameterOptimization::computeLocalMatrixK(double *& localK, int tetrahedronId, double youngsModulus, double poissonRatio, int derivative)
{
	if((tetrahedronId < 0) || (tetrahedronId >= allTetrahedra.size())) return;
	int i, offset;
	double volume, mu, lambda, det;
	double * matrixC, * matrixB, * helpMat;

	matrixC = new double[6*6];
	matrixB = new double[6*12];
	helpMat = new double[6*12];
	vector<double> x, y, z;

	for(i = 0; i < 12*12; i++) localK[i] = 0;

	//Compute the constant matrix C:
	
	if(derivative == 0)
	{
		//Derivative of Lame parameters w.r.t. poissonRatio
		lambda = (youngsModulus * ((1.0+poissonRatio)*(1.0-2.0*poissonRatio) + poissonRatio*(1.0+4.0*poissonRatio))) / (pow((1.0+poissonRatio)*(1.0-2.0*poissonRatio), 2.0));
		mu = -youngsModulus / (2.0*pow((1.0+poissonRatio), 2.0));
	}
	else if(derivative == 1)
	{
		//Derivative of Lame parameters w.r.t. youngsModulus
		lambda = poissonRatio / ((1.0+poissonRatio)*(1.0-2.0*poissonRatio));
		mu = 1.0 / (2.0*(1.0+poissonRatio));
	}
	else if(derivative == -2)
	{
		//the input values are lambda and mu
		lambda = youngsModulus;
		mu = poissonRatio;
	}
	else
	{
		//Convert to Lame parameters (formulas, see http://www.engr.uconn.edu/~lanbo/G229Lect08031RockMech2.pdf)
		lambda = (youngsModulus*poissonRatio) / ((1.0+poissonRatio)*(1.0-2.0*poissonRatio));
		mu = youngsModulus / (2.0*(1.0+poissonRatio)); 
	}

	for(i = 0; i < 6*6; i++) matrixC[i] = 0;
	matrixC[0] = matrixC[7] = matrixC[14] = lambda + 2*mu;
	matrixC[21] = matrixC[28] = matrixC[35] = mu;
	matrixC[1] = matrixC[2] = matrixC[6] = matrixC[8] = matrixC[12] = matrixC[13] = lambda;

	//Compute the matrix B:
	x.push_back(allNodes[allTetrahedra[tetrahedronId][0]]->coordinate().x());
	x.push_back(allNodes[allTetrahedra[tetrahedronId][1]]->coordinate().x());
	x.push_back(allNodes[allTetrahedra[tetrahedronId][2]]->coordinate().x());
	x.push_back(allNodes[allTetrahedra[tetrahedronId][3]]->coordinate().x());

	y.push_back(allNodes[allTetrahedra[tetrahedronId][0]]->coordinate().y());
	y.push_back(allNodes[allTetrahedra[tetrahedronId][1]]->coordinate().y());
	y.push_back(allNodes[allTetrahedra[tetrahedronId][2]]->coordinate().y());
	y.push_back(allNodes[allTetrahedra[tetrahedronId][3]]->coordinate().y());

	z.push_back(allNodes[allTetrahedra[tetrahedronId][0]]->coordinate().z());
	z.push_back(allNodes[allTetrahedra[tetrahedronId][1]]->coordinate().z());
	z.push_back(allNodes[allTetrahedra[tetrahedronId][2]]->coordinate().z());
	z.push_back(allNodes[allTetrahedra[tetrahedronId][3]]->coordinate().z());

	//1. Compute the volume
	for(i = 0; i < 6*12; i++) helpMat[i] = 0;
	helpMat[0] = helpMat[4] = helpMat[8] = helpMat[12] = 1.0;
	helpMat[1] = x[0]; helpMat[2] = y[0]; helpMat[3] = z[0];
	helpMat[5] = x[1]; helpMat[6] = y[1]; helpMat[7] = z[1];
	helpMat[9] = x[2]; helpMat[10] = y[2]; helpMat[11] = z[2];
	helpMat[13] = x[3]; helpMat[14] = y[3]; helpMat[15] = z[3];

	volume = computeDeterminant(helpMat, 4) / 6.0;

	//If the volume is zero, just give zero back (no need to compute everything since it will be multiplied by zero in the end anyways)
	if(volume == 0)
	{
		for(i = 0; i < 12*12; i++) localK[i] = 0;
		
		delete [] matrixC;
		delete [] matrixB;
		delete [] helpMat;
	}

	else
	{
		//2. Fill the matrix
		for(i = 0; i < 6*12; i++) matrixB[i] = 0;

		//b1
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[1]; helpMat[2] = z[1]; helpMat[4] = y[2]; helpMat[5] = z[2]; helpMat[7] = y[3]; helpMat[8] = z[3];
		det = -computeDeterminant(helpMat, 3);
		matrixB[0] = matrixB[9] = matrixB[17] = det;
		//c1
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[1]; helpMat[2] = z[1]; helpMat[4] = x[2]; helpMat[5] = z[2]; helpMat[7] = x[3]; helpMat[8] = z[3];
		det = computeDeterminant(helpMat, 3);
		matrixB[3] = matrixB[7] = matrixB[16] = det;
		//d1
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[1]; helpMat[2] = y[1]; helpMat[4] = x[2]; helpMat[5] = y[2]; helpMat[7] = x[3]; helpMat[8] = y[3];
		det = -computeDeterminant(helpMat, 3);
		matrixB[5] = matrixB[10] = matrixB[14] = det;
		
		//b2
		offset = 18;
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[2]; helpMat[2] = z[2]; helpMat[4] = y[3]; helpMat[5] = z[3]; helpMat[7] = y[0]; helpMat[8] = z[0];
		det = computeDeterminant(helpMat, 3);
		matrixB[offset+0] = matrixB[offset+9] = matrixB[offset+17] = det;
		//c2
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[2]; helpMat[2] = z[2]; helpMat[4] = x[3]; helpMat[5] = z[3]; helpMat[7] = x[0]; helpMat[8] = z[0];
		det = -computeDeterminant(helpMat, 3);
		matrixB[offset+3] = matrixB[offset+7] = matrixB[offset+16] = det;
		//d2
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[2]; helpMat[2] = y[2]; helpMat[4] = x[3]; helpMat[5] = y[3]; helpMat[7] = x[0]; helpMat[8] = y[0];
		det = computeDeterminant(helpMat, 3);
		matrixB[offset+5] = matrixB[offset+10] = matrixB[offset+14] = det;

		//b3
		offset = 36;
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[3]; helpMat[2] = z[3]; helpMat[4] = y[0]; helpMat[5] = z[0]; helpMat[7] = y[1]; helpMat[8] = z[1];
		det = -computeDeterminant(helpMat, 3);
		matrixB[offset+0] = matrixB[offset+9] = matrixB[offset+17] = det;
		//c3
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[3]; helpMat[2] = z[3]; helpMat[4] = x[0]; helpMat[5] = z[0]; helpMat[7] = x[1]; helpMat[8] = z[1];
		det = computeDeterminant(helpMat, 3);
		matrixB[offset+3] = matrixB[offset+7] = matrixB[offset+16] = det;
		//d3
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[3]; helpMat[2] = y[3]; helpMat[4] = x[0]; helpMat[5] = y[0]; helpMat[7] = x[1]; helpMat[8] = y[1];
		det = -computeDeterminant(helpMat, 3);
		matrixB[offset+5] = matrixB[offset+10] = matrixB[offset+14] = det;

		//b4
		offset = 54;
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[0]; helpMat[2] = z[0]; helpMat[4] = y[1]; helpMat[5] = z[1]; helpMat[7] = y[2]; helpMat[8] = z[2];
		det = computeDeterminant(helpMat, 3);
		matrixB[offset+0] = matrixB[offset+9] = matrixB[offset+17] = det;
		//c4
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[0]; helpMat[2] = z[0]; helpMat[4] = x[1]; helpMat[5] = z[1]; helpMat[7] = x[2]; helpMat[8] = z[2];
		det = -computeDeterminant(helpMat, 3);
		matrixB[offset+3] = matrixB[offset+7] = matrixB[offset+16] = det;
		//d4
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[0]; helpMat[2] = y[0]; helpMat[4] = x[1]; helpMat[5] = y[1]; helpMat[7] = x[2]; helpMat[8] = y[2];
		det = computeDeterminant(helpMat, 3);
		matrixB[offset+5] = matrixB[offset+10] = matrixB[offset+14] = det;

		for(i = 0; i < 6*12; i++) matrixB[i] = matrixB[i] / max((6.0*volume), THRESHOLD_DIV_ZERO);

		//Multiply the matrices:
		long int dim1, dim2;
		char transY, transN;
		double alpha, beta;
		transY = 'T';
		transN = 'N';
		dim1 = 6; 
		dim2 = 12;
		alpha = 1.0;
		beta = 0.0;

		for(i = 0; i < 6*12; i++) helpMat[i] = 0;

		clapack::dgemm_(&transY, &transN, &dim2, &dim1, &dim1, &alpha, matrixB, &dim1, matrixC, &dim1, &beta, helpMat, &dim2);
		clapack::dgemm_(&transN, &transN, &dim2, &dim2, &dim1, &alpha, helpMat, &dim2, matrixB, &dim1, &beta, localK, &dim2);

		for(i = 0; i < 12*12; i++) localK[i] *= volume; 


		delete [] matrixC;
		delete [] matrixB;
		delete [] helpMat;
	}
}

double ElasticParameterOptimization::computeDeterminant(double * matrix, int matrixDimension)
{
	//Check for validity of dimension
	if((matrixDimension < 1) || (matrixDimension > 4)) 
	{
		cout<<"Invalid dimensions in computeDeterminant"<<endl;
		return -1;
	}
	else if(matrixDimension == 1) return matrix[0];
	else if(matrixDimension == 2) return matrix[0]*matrix[3]-matrix[1]*matrix[2];
	else if(matrixDimension == 3) 
	{
		double det = matrix[0]*matrix[4]*matrix[8] + matrix[1]*matrix[5]*matrix[6] + matrix[2]*matrix[3]*matrix[7] - 
			   matrix[0]*matrix[5]*matrix[7] - matrix[1]*matrix[3]*matrix[8] - matrix[2]*matrix[4]*matrix[6];
		return det;
	}
	else 
	{
		double * helpMat = new double[9];
		double det = 0;

		//Use Laplace formula
		helpMat[0] = matrix[5]; helpMat[1] = matrix[6]; helpMat[2] = matrix[7];
		helpMat[3] = matrix[9]; helpMat[4] = matrix[10]; helpMat[5] = matrix[11];
		helpMat[6] = matrix[13]; helpMat[7] = matrix[14]; helpMat[8] = matrix[15];


		det += matrix[0] * computeDeterminant(helpMat, 3);

		helpMat[0] = matrix[1]; helpMat[1] = matrix[2]; helpMat[2] = matrix[3];
		helpMat[3] = matrix[9]; helpMat[4] = matrix[10]; helpMat[5] = matrix[11];
		helpMat[6] = matrix[13]; helpMat[7] = matrix[14]; helpMat[8] = matrix[15];

		det -= matrix[4] * computeDeterminant(helpMat, 3);

		helpMat[0] = matrix[1]; helpMat[1] = matrix[2]; helpMat[2] = matrix[3];
		helpMat[3] = matrix[5]; helpMat[4] = matrix[6]; helpMat[5] = matrix[7];
		helpMat[6] = matrix[13]; helpMat[7] = matrix[14]; helpMat[8] = matrix[15];

		det += matrix[8] * computeDeterminant(helpMat, 3);

		helpMat[0] = matrix[1]; helpMat[1] = matrix[2]; helpMat[2] = matrix[3];
		helpMat[3] = matrix[5]; helpMat[4] = matrix[6]; helpMat[5] = matrix[7];
		helpMat[6] = matrix[9]; helpMat[7] = matrix[10]; helpMat[8] = matrix[11];

		det -= matrix[12] * computeDeterminant(helpMat, 3);

		delete [] helpMat;

		return det;
	}
}



void ElasticParameterOptimization::computeContactArea()
{
	contactTriArea = 0;

	//calcultate the area of triangles that contain contact points
	for(int i = 0; i < trianglesOnSurface.size(); i++){

		 set<int>::iterator triangleIt = trianglesOnSurface[i].begin();
		 int n0 = *(triangleIt++), n1 = *(triangleIt++), n2 = *triangleIt;
		
		for(triangleIt = trianglesOnSurface[i].begin(); triangleIt != trianglesOnSurface[i].end(); triangleIt++){
			int n = *triangleIt;

			if(ISContactNode(n)!=-1){
			
				g_Vector AB(allNodes[n1]->coordinate() - allNodes[n0]->coordinate());
				g_Vector AC(allNodes[n2]->coordinate() - allNodes[n0]->coordinate());
				contactTriArea += AB.Cross(AC).length() / (2.0 * 3.0);
			}
		}

	}
	

	cout<<endl<<"Contact Area: "<<contactTriArea<<" mxm"<<endl;

}

/*void ElasticParameterOptimization::computeDisplacement(double* Qcalc)
{
	g_NodeContainer newPositions;
	
	for ( int i=0; i<numNodes; ++i) {
	  g_Node* deformedPos = new g_Node( *allNodes[i] );
	  deformedPos->coordinate(deformedPos->coordinate() 
				  + g_Vector(Qcalc[3*i],Qcalc[3*i+1],Qcalc[3*i+2]));
				  // + g_Vector(Q[3*i],Q[3*i+1],Q[3*i+2]));
	  newPositions.push_back(deformedPos);
	}

	//Compute new matching information for the deformed mesh
	CorrespondTemplates* corresDeformed = new CorrespondTemplates();
	corresDeformed->setAlignedSurface(frameMesh);
	corresDeformed->setTetModel(newPositions, allTetrahedra);
	corresDeformed->computeMappings( 0, 0, 0);
	//maps tetmesh to surface mesh
	vector<int> mapDefIndices = corresDeformed->getMappingIndicesTet();
	vector<double> mapDefWeights = corresDeformed->getMappingWeightsTet();
	delete corresDeformed;

	for ( int i=0; i<numNodes; ++i) {
	  delete newPositions[i];
	}

	//compute the displacement vector (Q = currentNodePos - allNodes)
	if(Q == NULL) Q = new double[3*numNodes];

	for(int i = 0; i < numNodes; i++){
		if(mapStartIndices[3*i] == -1){//interior node
			Q[3*i] = 0;
			Q[3*i+1] = 0;
			Q[3*i+2] = 0;
		}else{//surface node

			g_Vector mappedDisplacement = mapDefWeights[3*i] * frameMesh->nodes()[mapDefIndices[3*i]]->coordinate() 
			  - mapStartWeights[3*i] * templateMesh->nodes()[mapStartIndices[3*i]]->coordinate() +
			  mapDefWeights[3*i+1] * frameMesh->nodes()[mapDefIndices[3*i+1]]->coordinate() 
			  - mapStartWeights[3*i+1] * templateMesh->nodes()[mapStartIndices[3*i+1]]->coordinate() +
			  mapDefWeights[3*i+2] * frameMesh->nodes()[mapDefIndices[3*i+2]]->coordinate() 
			  - mapStartWeights[3*i+2] * templateMesh->nodes()[mapStartIndices[3*i+2]]->coordinate();
			

			// #define  _FIX_DISPLACEMENT_DIRECTION_
#ifdef _FIX_DISPLACEMENT_DIRECTION_
			if(ISContactNode(i) != -1) {
			  cerr << ">>>>> Correcting displacement " << i << endl;
			  double mag = mappedDisplacement.length();
			  g_Vector dir = g_Vector( frameForce[3*numFrame],
						 frameForce[3*numFrame+1],
						 frameForce[3*numFrame+2] );
			  dir.normalize();
			  dir = mag * dir;
			  Q[3*i] = dir.x();
			  Q[3*i+1] = dir.y();
			  Q[3*i+2] = dir.z();
			  
			} else
#endif 
			{
			Q[3*i] = mappedDisplacement.x();
			Q[3*i+1] = mappedDisplacement.y();
			Q[3*i+2] = mappedDisplacement.z();
			}
			
		}
	}

}*/

void ElasticParameterOptimization::computeDisplacement(TriangleMesh * frMesh)
{
	frameMesh = frMesh;

	g_NodeContainer * newPositions;

	//compute the displacement vector (Q = currentNodePos - allNodes)
	if(Q == NULL) Q = new double[3*numNodes];

	for(int i = 0; i < numNodes; i++){
		if(mapStartIndices[3*i] == -1){//interior node
			Q[3*i] = 0;
			Q[3*i+1] = 0;
			Q[3*i+2] = 0;
		}else{//surface node

			g_Vector mappedDisplacement = mapStartWeights[3*i] * ( frameMesh->nodes()[mapStartIndices[3*i]]->coordinate() - templateMesh->nodes()[mapStartIndices[3*i]]->coordinate() ) +
			                              mapStartWeights[3*i+1] * ( frameMesh->nodes()[mapStartIndices[3*i+1]]->coordinate() - templateMesh->nodes()[mapStartIndices[3*i+1]]->coordinate() ) + 
			                              mapStartWeights[3*i+2] * ( frameMesh->nodes()[mapStartIndices[3*i+2]]->coordinate() - templateMesh->nodes()[mapStartIndices[3*i+2]]->coordinate() ) ;
			

			Q[3*i] = mappedDisplacement.x();
			Q[3*i+1] = mappedDisplacement.y();
			Q[3*i+2] = mappedDisplacement.z();
			
		}
	}
	 
#ifdef USE_SIMULATION_DISP
	char buf [500];
	FILE * fp;
	float x,y,z;
	sprintf(buf, "C:\\MTekieh\\ITK\\data\\foam\\simulation\\foamblock2\\ElasticDisplacements.txt");//new series
	fp = fopen(buf, "r");
	
		//read complete nodal displacements
		for(int i = 0; i < numNodes; i++){
			fscanf(fp, "%f %f %f ", &x, &y, &z);
			Q[3*i] = x;
			Q[3*i+1] = y;
			Q[3*i+2] = z;
		}
#endif
	
}

void ElasticParameterOptimization::readForce(char * forceFileName)
{
	char buffer[500];

	if (forceFileName)
	{
		FILE * fpForceFile = fopen(forceFileName, "r");
		while(fscanf(fpForceFile,"%s ", &buffer) != EOF){
			float fx, fy, fz;
			FILE * fpForce = fopen(buffer, "r");
			fscanf(fpForce, "%f %f %f", &fx, &fy, &fz);
			frameForce.push_back(fx);frameForce.push_back(fy);frameForce.push_back(fz);
		}
	}
}

void ElasticParameterOptimization::setForce()
{
	int index;

	if(F == NULL) F = new double[3*numNodes];

	// measuredForce = contactTriArea * (f_A + f_B + f_C)
	 double contactArea = M_PI * contactRadius*contactRadius;
	 bool contactTridir = true;
	
	 for(int i = 0; i < numNodes; i++){
		if((index = ISContactNode(i)) != -1){
						  
#ifdef _FIX_FORCE_DIRECTION_
			  cerr << ">>>>> Correcting force " << i << endl;
			  g_Vector dir  = g_Vector( Q[3*i], Q[3*i+1], Q[3*i+2] );
			  g_Vector frameF = g_Vector(frameForce[3*numFrame], frameForce[3*numFrame+1], frameForce[3*numFrame+2]);

			  if (contactTridir){
				  g_Vector a = g_Vector(allNodes[contactNodes[1]]->coordinate() - allNodes[contactNodes[0]]->coordinate());
				  g_Vector b = g_Vector(allNodes[contactNodes[2]]->coordinate() - allNodes[contactNodes[0]]->coordinate());
				  dir  = a.Cross(b);
				  if(dir.Dot(frameF) < 0) //if the direction have more than 90 deg angle with original force vector
					  dir *= -1;
			  }
			  g_Vector f  = g_Vector( frameForce[3*numFrame] * contactTriArea / contactArea,
						  frameForce[3*numFrame+1] * contactTriArea / contactArea,
						  frameForce[3*numFrame+2] * contactTriArea / contactArea );
			  double mag = f.length();
			  dir.normalize();
			  dir = mag * dir;

			  F[3*i] = dir.x();
			  F[3*i+1] = dir.y();
			  F[3*i+2] = dir.z();

#else


			 F[3*i] = frameForce[3*numFrame] * contactTriArea / contactArea;
			  F[3*i+1] = frameForce[3*numFrame+1] * contactTriArea / contactArea;
			  F[3*i+2] = frameForce[3*numFrame+2] * contactTriArea /contactArea;
#endif
			cout<<"Contact Node: "<<i<<"  Force values: "<<F[3*i]<<"  "<<F[3*i+1]<<"  "<<F[3*i+2]<<endl;


//---------			
// #define  _FIX_DISPLACEMENT_DIRECTION_
#ifdef _FIX_DISPLACEMENT_DIRECTION_
			
			  cerr << ">>>>> Correcting displacement " << i << endl;
			  double mag = g_Vector(Q[3*i], Q[3*i+1], Q[3*i+2]).length();
			  g_Vector dir = g_Vector( frameForce[3*numFrame], frameForce[3*numFrame+1], frameForce[3*numFrame+2] );
			  dir.normalize();
			  dir = mag * dir;
			  Q[3*i] = dir.x();
			  Q[3*i+1] = dir.y();
			  Q[3*i+2] = dir.z();
			
#endif 
//---------

		}else{
			F[3*i] = 0;
			F[3*i+1] = 0;
			F[3*i+2] = 0;
		}
	}

#ifdef USE_SIMULATION_FORCE
	F[3*117]=-3.58855e-005;F[3*117+1]=-20.7637;F[3*117+2]=-3.40383e-005;//new series
    F[3*133]=1.68531e-005;F[3*133+1]=-20.7637;F[3*133+2]=-3.97747e-005;
    F[3*139]=-3.20315e-005;F[3*139+1]=-20.7638;F[3*139+2]=-1.475e-005;
	
#endif
}

void ElasticParameterOptimization::setSupportSurfaceNodes(char * supportSurfFileName)
{
	numSuppNodes = 0;
	g_NodeContainer supportPointCloud; supportPointCloud.clear();
	TriangleMesh * supportPlaneNodes = new TriangleMesh();

	importMeshWrapper( supportSurfFileName, supportPlaneNodes );

	/*Ax + By + Cz + D = 0
	A = y1 (z2 - z3) + y2 (z3 - z1) + y3 (z1 - z2)
	B = z1 (x2 - x3) + z2 (x3 - x1) + z3 (x1 - x2)
	C = x1 (y2 - y3) + x2 (y3 - y1) + x3 (y1 - y2)
	D = -x1 (y2 z3 - y3 z2) - x2 (y3 z1 - y1 z3) - x3 (y1 z2 - y2 z1)
	Ax0 + By0 + Cz0 + D > 0 or Ax0 + By0 + Cz0 + D < 0 not on the plane*/

	g_Plane supportPlane(supportPlaneNodes->nodes()[0]->coordinate(), supportPlaneNodes->nodes()[1]->coordinate(), supportPlaneNodes->nodes()[2]->coordinate());
	
	for(int i = 0; i < numNodes; i++){

		if(fabs(supportPlane.distanceToPoint(allNodes[i]->coordinate())) > SUPPORT_SURF_THR)
			supportSurfNodes.push_back(-1); //not on support surface

		else{
			supportSurfNodes.push_back(1); //is on support surface
			numSuppNodes++;
			g_Node * newNode = new g_Node(allNodes[i]->coordinate()); 
			supportPointCloud.insert(newNode);
		
		}
	}
	
	//write out the support surface
	std::ofstream ofSuppSurf( "SupportSurfaceNodes.off"); 
	ofSuppSurf << "OFF\n" << numSuppNodes << " 0 0\n";
	const g_NodeContainer& supportPointCloudC = supportPointCloud;
	for( g_NodeContainer::const_iterator nIt=supportPointCloudC.begin();
		    nIt != supportPointCloudC.end(); ++nIt ) {
		ofSuppSurf << (*nIt)->coordinate() << std::endl;
	}
	ofSuppSurf.close();

	delete supportPlaneNodes;
	for(int i = 0; i < numSuppNodes; i++)
		delete supportPointCloud[i];
	supportPointCloud.clear();
	

}

int ElasticParameterOptimization::ISContactNode(int Node)
{
	for(int i = 0; i < numContactPoints; i++)
		if(contactNodes[i] == Node)
			return i;

	return -1;
}

void ElasticParameterOptimization::optimizationSetup(int maxIter){

#ifdef USE_LINEAR_OPT

	linLameOpt = new LinearLameOpt(this, maxIter);

#endif //USE_LINEAR_OPT


#ifdef USE_NONLINEAR_OPT

	nonlinLameOpt = new NonLinearLameOpt(this, maxIter);

#endif //USE_NONLINEAR_OPT

}

void ElasticParameterOptimization::computeElasticityParameters(int Frame, int maxIter)
{
	numFrame = Frame;
	lambda.clear();
	mu.clear();
	residualsqrt.clear();
	overallError.clear();
	overallErrorDisp.clear();
	overallErrorForce.clear();

	

	// Allocate error variables here
	nodeError = new double[3*numNodes];
	normalError = new double[3*numNodes];
	double *Qcalc = new double[3*numNodes];

	//assigns the frame force to the contact nodes
	setForce();

	
	exportSolidMesh("Solidmesh-SetFQ.vtk");
	/*char buf22[128];
	sprintf(buf22,"%s.txt", "Force_set");
	print(F, dimension, 1, buf22);
	sprintf(buf22,"%s.txt", "Displacement_set");
	print(Q, dimension, 1, buf22);*/


	


	//call linear/nonlinear constructors
	optimizationSetup(maxIter);
	

	
	cout<<endl<<"FRAME NO.: "<<numFrame<<endl<<"-------------"<<endl;

	
	
#ifdef USE_LINEAR_OPT
		linLameOpt->computeLameParam();
		
#endif //USE_LINEAR_OPT


	
#ifdef USE_NONLINEAR_OPT

                        

		// std::ostringstream os;
		// os << "matA_" << iter  << ".txt";  
		// std::ofstream matAFile( os.str().c_str() );
		// os.clear(); os.str("");
		// os << "vecB_" << iter  << ".txt";  
		// std::ofstream vecBFile( os.str().c_str() );
		// for (int i = 0; i < j; i++){
		//   matAFile << A[3*i] << " " << A[3*numUsedEqn+3*i] << endl;
		//   matAFile << A[3*i+1] << " " << A[3*numUsedEqn+3*i+1] << endl;
		//   matAFile << A[3*i+2] << " " << A[3*numUsedEqn+3*i+2] << endl;
		//   vecBFile << b[3*i] << endl;
		//   vecBFile << b[3*i+1] << endl;
		//   vecBFile << b[3*i+2] << endl;
		// }
		// matAFile.close();
		// vecBFile.close();
		cerr << "Nonlinear optimization: " << endl;



		nonlinLameOpt->computeLameParam();


#endif //USE_NONLINEAR_OPT

	
	//compute the free surface displacement using fitted parameters
	computeFreeSurfDisplacement(Qcalc,*lambda.rbegin(),*mu.rbegin());
	//compute the displacement error
	computeDisplacementError(Qcalc);
	

	char buf[128];
	sprintf(buf,"%s%d.txt", "ElasticityParameters", numFrame);
	printParameters(buf);

	delete [] Qcalc;
	delete [] Q; Q = NULL;
	delete [] F; F = NULL;
	delete [] nodeError;nodeError = NULL;
	delete [] normalError;normalError = NULL;
	
#ifdef USE_LINEAR_OPT
	delete linLameOpt; linLameOpt = NULL;
#endif

#ifdef USE_NONLINEAR_OPT
	delete nonlinLameOpt; nonlinLameOpt = NULL;
#endif

}


double * ElasticParameterOptimization::computeReducedYoungsModulus(double poisson){

	// Calculate the reduced Young's modulus based on the contact nodes
	// Estar = 3/4 * F/sqrt(R * d^3)
	
	g_Vector F_contact = g_Vector(frameForce[3*numFrame], frameForce[3*numFrame+1], frameForce[3*numFrame+2]);
	g_Vector F_dir( F_contact );
	F_dir.Normalize();
	double u_max = 0.0;	
	for(int i = 0; i < numContactPoints; i++) {
			double u_contact = F_dir.Dot( g_Vector(Q[3*contactNodes[i]],Q[3*contactNodes[i]+1],Q[3*contactNodes[i]+2]));
			u_max = (u_contact > u_max)?u_contact:u_max; 	
    }
	double Estar = 0.75 * F_contact.length() / sqrt( contactRadius * u_max * u_max * u_max );
	// set initial lambda and mu with poisson = 0.45
	
	double Eyoung = Estar * (1.0-poisson*poisson);
	double Lambda = Eyoung * poisson / (1.0+poisson)/(1.0-2.0*poisson);
	double Mu = Eyoung/(2.0*(1.0+poisson));
	cerr << "Estar: " << Estar << " with " << F_contact.length() << " " << u_max << endl;
	d_Umax = u_max;
	d_Fmax = F_contact.length();

	double * param = new double[3];
	param[0] = Lambda;
	param[1] = Mu;
	param[2] = Estar;
	return param;
}

void ElasticParameterOptimization::computeFreeSurfDisplacement(double* Qcalc, double Lambda, double Mu){
	long int dimension, dim2, variabledim, nrhs, info, lwork;
	char trans;
	dim2 = 2;
	dimension = 3 * numNodes;
	variabledim = 3 * (numInterNodes + numFreeSNodes + numContactPoints + numSuppNodes);
	nrhs = 1;
	trans = 'N';
	info = 0;
	lwork =  dim2 * dimension;
	double * work = new double[lwork];
	
	// Initialize displacement
	for ( int i=0; i<dimension; ++i ) Qcalc[i]=Q[i]; 
	//compute matrix K 
	computeMatrixK(Lambda, Mu, -2);                                            
	//vector Fprim is combination of known forces and displacements
	double * Fprim = new double[dimension];
	double * Kprim = new double[dimension*variabledim];
			

	//re-arranging the equations to have all the unknowns in one vector
	int forcepos = 0;
	for(int i = 0; i < numNodes; i++){

			
		//set the modified matrix K for interior nodes for which displacement is unknown
		for(int j = 0; j < numInterNodes; j++){
			Kprim[(3*j)*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*interNodes[j])+(3*i)];
			Kprim[(3*j)*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*interNodes[j])+(3*i+1)];
			Kprim[(3*j)*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*interNodes[j])+(3*i+2)];

			Kprim[(3*j+1)*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*interNodes[j]+1)+(3*i)];
			Kprim[(3*j+1)*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*interNodes[j]+1)+(3*i+1)];
			Kprim[(3*j+1)*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*interNodes[j]+1)+(3*i+2)];

			Kprim[(3*j+2)*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*interNodes[j]+2)+(3*i)];
			Kprim[(3*j+2)*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*interNodes[j]+2)+(3*i+1)];
			Kprim[(3*j+2)*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*interNodes[j]+2)+(3*i+2)];
		}

		//set the modified matrix K for free surface nodes for which displacement is unknown
		for(int j = 0; j < numFreeSNodes; j++){
			Kprim[((3*numInterNodes)+(3*j))*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j])+(3*i)];
			Kprim[((3*numInterNodes)+(3*j))*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j])+(3*i+1)];
			Kprim[((3*numInterNodes)+(3*j))*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j])+(3*i+2)];

			Kprim[((3*numInterNodes)+(3*j+1))*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j]+1)+(3*i)];
			Kprim[((3*numInterNodes)+(3*j+1))*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j]+1)+(3*i+1)];
			Kprim[((3*numInterNodes)+(3*j+1))*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j]+1)+(3*i+2)];

			Kprim[((3*numInterNodes)+(3*j+2))*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j]+2)+(3*i)];
			Kprim[((3*numInterNodes)+(3*j+2))*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j]+2)+(3*i+1)];
			Kprim[((3*numInterNodes)+(3*j+2))*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*freeSurfNodes[j]+2)+(3*i+2)];
		}

		//set the modified matrix K for contact nodes for which displacement is unknown
		for(int j = 0; j < numContactPoints; j++){
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j))*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*contactNodes[j])+(3*i)];
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j))*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*contactNodes[j])+(3*i+1)];
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j))*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*contactNodes[j])+(3*i+2)];

		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j+1))*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*contactNodes[j]+1)+(3*i)];
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j+1))*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*contactNodes[j]+1)+(3*i+1)];
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j+1))*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*contactNodes[j]+1)+(3*i+2)];

		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j+2))*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*contactNodes[j]+2)+(3*i)];
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j+2))*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*contactNodes[j]+2)+(3*i+1)];
		  Kprim[(3*(numInterNodes+numFreeSNodes)+(3*j+2))*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*contactNodes[j]+2)+(3*i+2)];
		}

		//set the modified matrix K for support surface nodes for which force is unknown
		for(int j = 0; j < (numSuppNodes); j++){
		        Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j))*(3*numNodes)+(3*i)] = 0;
		        Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j))*(3*numNodes)+(3*i+1)] = 0;
			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j))*(3*numNodes)+(3*i+2)] = 0;

			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j+1))*(3*numNodes)+(3*i)] = 0;
			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j+1))*(3*numNodes)+(3*i+1)] = 0;
			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j+1))*(3*numNodes)+(3*i+2)] = 0;

			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j+2))*(3*numNodes)+(3*i)] = 0;
			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j+2))*(3*numNodes)+(3*i+1)] = 0;
			Kprim[(3*(numInterNodes+numFreeSNodes+numContactPoints)+(3*j+2))*(3*numNodes)+(3*i+2)] = 0;
					
		}

		//support surface nodes (in this case the force is unknown and has coefficient -1 in new arrangement of matrix K)

		if(supportSurfNodes[i] == 1){
		    Kprim[((3*(numInterNodes+numFreeSNodes+numContactPoints))+(3*forcepos))*(3*numNodes)+(3*i)] = -1;
			Kprim[((3*(numInterNodes+numFreeSNodes+numContactPoints))+(3*forcepos+1))*(3*numNodes)+(3*i+1)] = -1;
			Kprim[((3*(numInterNodes+numFreeSNodes+numContactPoints))+(3*forcepos+2))*(3*numNodes)+(3*i+2)] = -1;

			forcepos++;

			Fprim[3*i] = 0;
			Fprim[3*i+1] = 0;
			Fprim[3*i+2] = 0;
		}
		else{//contact nodes or interior nodes or free surface nodes ar  known forces
			Fprim[3*i] = F[3*i];
			Fprim[3*i+1] = F[3*i+1];
			Fprim[3*i+2] = F[3*i+2];
		}

		//set the modified vector F (bring all the known terms of the equation to one side)
		for(int j = 0; j < numNodes; j++){
			if(mapStartIndices[3*j] != -1  && supportSurfNodes[i] == 1){// the known terms are the ones with known displacement: support surface node
				Fprim[3*i] -= matrixK[(3*j)*(3*numNodes)+(3*i)] * Q[3*j];
				Fprim[3*i] -= matrixK[(3*j+1)*(3*numNodes)+(3*i)] * Q[3*j+1];
				Fprim[3*i] -= matrixK[(3*j+2)*(3*numNodes)+(3*i)] * Q[3*j+2];

				Fprim[3*i+1] -= matrixK[(3*j)*(3*numNodes)+(3*i+1)] * Q[3*j];
				Fprim[3*i+1] -= matrixK[(3*j+1)*(3*numNodes)+(3*i+1)] * Q[3*j+1];
				Fprim[3*i+1] -= matrixK[(3*j+2)*(3*numNodes)+(3*i+1)] * Q[3*j+2];

				Fprim[3*i+2] -= matrixK[(3*j)*(3*numNodes)+(3*i+2)] * Q[3*j];
				Fprim[3*i+2] -= matrixK[(3*j+1)*(3*numNodes)+(3*i+2)] * Q[3*j+1];
				Fprim[3*i+2] -= matrixK[(3*j+2)*(3*numNodes)+(3*i+2)] * Q[3*j+2];
			}
		}
			
	}

	
		//solve the F'= K' * U' to find the interior displacement
		clapack::dgels_(&trans, &dimension, &variabledim, &nrhs, Kprim, &dimension, Fprim, &dimension, work, &lwork, &info);       

		//update the interior displacements
		for(int i = 0; i < numInterNodes; i++){
			Qcalc[3*interNodes[i]] = Fprim[3*i];
			Qcalc[3*interNodes[i]+1] = Fprim[3*i+1];
			Qcalc[3*interNodes[i]+2] = Fprim[3*i+2];
		}

		//update free surface displacements
		forcepos = numInterNodes;
		for(int i = 0; i < numFreeSNodes; i++){
			Qcalc[3*freeSurfNodes[i]] = Fprim[3*forcepos];
			Qcalc[3*freeSurfNodes[i]+1] = Fprim[3*forcepos+1];
			Qcalc[3*freeSurfNodes[i]+2] = Fprim[3*forcepos+2];

			forcepos++;
		}

		// Update contact displacement 
		forcepos = numInterNodes + numFreeSNodes;
		for(int i = 0; i < numContactPoints; i++) {
		    Qcalc[3*contactNodes[i]] = Fprim[3*forcepos];
		    Qcalc[3*contactNodes[i]+1] = Fprim[3*forcepos+1];
		    Qcalc[3*contactNodes[i]+2] = Fprim[3*forcepos+2];
		  
			forcepos++;
		}


		                                                                      
		delete [] work; delete [] Fprim; delete [] Kprim;
}

double ElasticParameterOptimization::computeDisplacementError(double* Qcalc, int iter ){
  double error = 0;

	for(int i = 0; i < numNodes; i++){
	  if(mapStartIndices[3*i] != -1 ){//consider error  for surface nodes
			g_Vector mappedDisplacement = mapStartWeights[3*i] * ( frameMesh->nodes()[mapStartIndices[3*i]]->coordinate() - templateMesh->nodes()[mapStartIndices[3*i]]->coordinate() ) +
			                              mapStartWeights[3*i+1] * ( frameMesh->nodes()[mapStartIndices[3*i+1]]->coordinate() - templateMesh->nodes()[mapStartIndices[3*i+1]]->coordinate() ) + 
			                              mapStartWeights[3*i+2] * ( frameMesh->nodes()[mapStartIndices[3*i+2]]->coordinate() - templateMesh->nodes()[mapStartIndices[3*i+2]]->coordinate() ) ;
			
			nodeError[3*i] = mappedDisplacement.x() - Qcalc[3*i];
			nodeError[3*i+1] = mappedDisplacement.y() - Qcalc[3*i+1];
			nodeError[3*i+2] = mappedDisplacement.z() - Qcalc[3*i+2];

			g_Vector qNode( Qcalc[3*i], Qcalc[3*i+1], Qcalc[3*i+2] );
			error += mappedDisplacement.DistanceTo( qNode );

			g_Vector dir =  mapStartWeights[3*i] * ( frameMesh->nodes()[mapStartIndices[3*i]]->coordinate()) +
			                mapStartWeights[3*i+1] * ( frameMesh->nodes()[mapStartIndices[3*i+1]]->coordinate()) + 
			                mapStartWeights[3*i+2] * ( frameMesh->nodes()[mapStartIndices[3*i+2]]->coordinate()) ;
			dir.normalize(); 

			double magnitude = g_Vector(nodeError[3*i], nodeError[3*i+1], nodeError[3*i+2]).length();
			dir = magnitude * dir;

			normalError[3*i] = dir.x(); 
			normalError[3*i+1] = dir.y();
			normalError[3*i+2] = dir.z();
		}else{
			nodeError[3*i] = 0;
			nodeError[3*i+1] = 0;
			nodeError[3*i+2] = 0;

			normalError[3*i] = 0; 
			normalError[3*i+1] = 0;
			normalError[3*i+2] = 0;
		}

	}
	
		char solidfn[128];
		sprintf(solidfn,"%s_%.3d_%.3d.vtk", "SolidMesh", numFrame, iter);
		exportSolidMesh(solidfn, Qcalc);

	//overallError.push_back(error);
	//cerr << "Overall displacement error: " << error << endl;
	return error;
}

void ElasticParameterOptimization::computeCalculatedForce(double* Fcalc, double Lambda, double Mu)
{
	//first compute interior node displacement with least square
	//then compute K(Lambda Mu)*Q to achieve calculated F  

	long int dimension, dim2, variabledim, nrhs, info, lwork;
	char trans;
	double alpha, beta;
	dim2 = 2;
	dimension = 3 * numNodes;
	variabledim = 3 * (numInterNodes + numSuppNodes);
	alpha = 1.0;
	beta = 0.0;
	nrhs = 1;
	trans = 'N';
	info = 0;
	lwork =  dim2 * dimension;
	double * work = new double[lwork];

	// Initialize displacement
	double * Qtemp = new double[dimension];
	for ( int i=0; i < dimension; ++i ) Qtemp[i]=Q[i]; 
	

	//find the interior displacement:
	//compute matrix K 
	computeMatrixK(Lambda, Mu, -2);                                            
	//vector Fprim is combination of known forces and displacements
	double * Fprim = new double[dimension];
	double * Kprim = new double[dimension*variabledim];

	//re-arranging the equations to have all the unknowns in one vector
	int forcepos = 0;
	for(int i = 0; i < numNodes; i++){
		//set the modified matrix K for interior nodes for which displacement is unknown
		for(int j = 0; j < numInterNodes; j++){
			Kprim[(3*j)*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*interNodes[j])+(3*i)];
			Kprim[(3*j)*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*interNodes[j])+(3*i+1)];
			Kprim[(3*j)*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*interNodes[j])+(3*i+2)];

			Kprim[(3*j+1)*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*interNodes[j]+1)+(3*i)];
			Kprim[(3*j+1)*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*interNodes[j]+1)+(3*i+1)];
			Kprim[(3*j+1)*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*interNodes[j]+1)+(3*i+2)];

			Kprim[(3*j+2)*(3*numNodes)+(3*i)] = matrixK[(3*numNodes)*(3*interNodes[j]+2)+(3*i)];
			Kprim[(3*j+2)*(3*numNodes)+(3*i+1)] = matrixK[(3*numNodes)*(3*interNodes[j]+2)+(3*i+1)];
			Kprim[(3*j+2)*(3*numNodes)+(3*i+2)] = matrixK[(3*numNodes)*(3*interNodes[j]+2)+(3*i+2)];
		}

		//set the modified matrix K for support surface nodes for which force is unknown
		for(int j = 0; j < (numSuppNodes); j++){
			Kprim[((3*numInterNodes)+(3*j))*(3*numNodes)+(3*i)] = 0;
			Kprim[((3*numInterNodes)+(3*j))*(3*numNodes)+(3*i+1)] = 0;
			Kprim[((3*numInterNodes)+(3*j))*(3*numNodes)+(3*i+2)] = 0;

			Kprim[((3*numInterNodes)+(3*j+1))*(3*numNodes)+(3*i)] = 0;
			Kprim[((3*numInterNodes)+(3*j+1))*(3*numNodes)+(3*i+1)] = 0;
			Kprim[((3*numInterNodes)+(3*j+1))*(3*numNodes)+(3*i+2)] = 0;

			Kprim[((3*numInterNodes)+(3*j+2))*(3*numNodes)+(3*i)] = 0;
			Kprim[((3*numInterNodes)+(3*j+2))*(3*numNodes)+(3*i+1)] = 0;
			Kprim[((3*numInterNodes)+(3*j+2))*(3*numNodes)+(3*i+2)] = 0;
					
		}

		//support surface nodes (in this case the force is unknown and has coefficient -1 in new arrangement of matrix K)
		if(supportSurfNodes[i] == 1){
			Kprim[((3*numInterNodes)+(3*forcepos))*(3*numNodes)+(3*i)] = -1;
			Kprim[((3*numInterNodes)+(3*forcepos+1))*(3*numNodes)+(3*i+1)] = -1;
			Kprim[((3*numInterNodes)+(3*forcepos+2))*(3*numNodes)+(3*i+2)] = -1;

			forcepos++;

			Fprim[3*i] = 0;
			Fprim[3*i+1] = 0;
			Fprim[3*i+2] = 0;
		}
		else{//contact nodes or interior nodes or free surface nodes are known forces
			Fprim[3*i] = F[3*i];
			Fprim[3*i+1] = F[3*i+1];
			Fprim[3*i+2] = F[3*i+2];
		}

		//set the modified vector F (bring all the known terms of the equation to one side)
		for(int j = 0; j < numNodes; j++){
			if(mapStartIndices[3*j] != -1){// the known terms are the ones with known displacement: all nodes except interior
				Fprim[3*i] -= matrixK[(3*j)*(3*numNodes)+(3*i)] * Qtemp[3*j];
				Fprim[3*i] -= matrixK[(3*j+1)*(3*numNodes)+(3*i)] * Qtemp[3*j+1];
				Fprim[3*i] -= matrixK[(3*j+2)*(3*numNodes)+(3*i)] * Qtemp[3*j+2];

				Fprim[3*i+1] -= matrixK[(3*j)*(3*numNodes)+(3*i+1)] * Qtemp[3*j];
				Fprim[3*i+1] -= matrixK[(3*j+1)*(3*numNodes)+(3*i+1)] * Qtemp[3*j+1];
				Fprim[3*i+1] -= matrixK[(3*j+2)*(3*numNodes)+(3*i+1)] * Qtemp[3*j+2];

				Fprim[3*i+2] -= matrixK[(3*j)*(3*numNodes)+(3*i+2)] * Qtemp[3*j];
				Fprim[3*i+2] -= matrixK[(3*j+1)*(3*numNodes)+(3*i+2)] * Qtemp[3*j+1];
				Fprim[3*i+2] -= matrixK[(3*j+2)*(3*numNodes)+(3*i+2)] * Qtemp[3*j+2];
			}
		}
			
	}


	//solve the F'= K' * U' to find the interior displacement
	clapack::dgels_(&trans, &dimension, &variabledim, &nrhs, Kprim, &dimension, Fprim, &dimension, work, &lwork, &info);       

	//update the interior displacements
	for(int i = 0; i < numInterNodes; i++){
		Qtemp[3*interNodes[i]] = Fprim[3*i];
		Qtemp[3*interNodes[i]+1] = Fprim[3*i+1];
		Qtemp[3*interNodes[i]+2] = Fprim[3*i+2];
	}


	delete [] Fprim; delete [] Kprim;


	clapack::dgemm_(&trans, &trans, &dimension, &nrhs, &dimension, &alpha, matrixK, &dimension, Qtemp, &dimension, &beta, Fcalc, &dimension);
	


	delete [] work;
	delete [] Qtemp;
}

double ElasticParameterOptimization::computeForceError(double* Fcalc)
{
	double error = 0;

	for(int i = 0; i < numNodes; i++){
		 if(supportSurfNodes[i] == -1 ){//do not consider support surface for force error because we don't know the correct value
			
			 g_Vector fmsrNode( F[3*i], F[3*i+1], F[3*i+2] );
			 g_Vector fcalNode( Fcalc[3*i], Fcalc[3*i+1], Fcalc[3*i+2] );
			 error += fmsrNode.DistanceTo( fcalNode );

		 }
	}


	return error;
}










ElasticParameterOptimization::LinearLameOpt::LinearLameOpt(ElasticParameterOptimization * const EPO, int maxIt){

	epo = EPO;

	//equation solving parameters
	numUsedEqn = epo->numNodes;//how many equation used to solve for mu and lambda
	dimension = 3 * epo->numNodes;
	variabledim = 3 * (epo->numInterNodes + epo->numSuppNodes);
	dim1 = 3 * numUsedEqn;
	dim2 = 2;
	nrhs = 1;
	trans = 'N';
	alpha = 1.0;
	beta = 0.0;
	info = 0;
	lwork =  dim2 * dimension;
	work = new double[lwork];
	maxIter = maxIt;

	double Lambda = INITIAL_LAMBDA;
	double Mu = INITIAL_MU;

#ifdef USE_REDUCED_YOUNGS_MODULUS
	// Calculate the reduced Young's modulus based on the contact nodes
	double * initialParam = computeReducedYoungsModulus();
	Lambda = initialParam[0];
	Mu = initialParam[1];
#endif

	cerr <<endl<<"Initializing.."<<endl<<"lambda=" << Lambda << " mu=" << Mu << endl;
	epo->lambda.push_back(Lambda);
	epo->mu.push_back(Mu);
	epo->residualsqrt.push_back(INITIAL_RESIDUAL);


	//compute the decomposed matrix K once since its constant
	matrixH = NULL;
	matrixJ = NULL;
	computeMatrix_H_J(matrixH, matrixJ);

	cout<<endl<<"LINEAR PARAMETER OPTIMIZATION"<<endl;
	cout<<"------------------------------"<<endl;
}

ElasticParameterOptimization::LinearLameOpt::~LinearLameOpt()
{
	if (work != NULL) delete [] work;
	if (matrixH != NULL) delete [] matrixH; 
	if (matrixJ != NULL) delete [] matrixJ;
}

void ElasticParameterOptimization::LinearLameOpt::computeLameParam(){

	double Lambda = epo->lambda[epo->lambda.size()-1];
	double Mu = epo->mu[epo->mu.size()-1];
	
	double *Qcalc = new double[dimension];
	
	for(int iter = 0; iter < maxIter; iter++){
			
		//find the interior displacement:
		//compute matrix K 
		epo->computeMatrixK(Lambda, Mu, -2);                                            
		//vector Fprim is combination of known forces and displacements
		double * Fprim = new double[dimension];
		double * Kprim = new double[dimension*variabledim];

		//re-arranging the equations to have all the unknowns in one vector
		int forcepos = 0;
		for(int i = 0; i < epo->numNodes; i++){
			//set the modified matrix K for interior nodes for which displacement is unknown
			for(int j = 0; j < epo->numInterNodes; j++){
				Kprim[(3*j)*(3*epo->numNodes)+(3*i)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j])+(3*i)];
				Kprim[(3*j)*(3*epo->numNodes)+(3*i+1)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j])+(3*i+1)];
				Kprim[(3*j)*(3*epo->numNodes)+(3*i+2)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j])+(3*i+2)];

				Kprim[(3*j+1)*(3*epo->numNodes)+(3*i)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j]+1)+(3*i)];
				Kprim[(3*j+1)*(3*epo->numNodes)+(3*i+1)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j]+1)+(3*i+1)];
				Kprim[(3*j+1)*(3*epo->numNodes)+(3*i+2)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j]+1)+(3*i+2)];

				Kprim[(3*j+2)*(3*epo->numNodes)+(3*i)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j]+2)+(3*i)];
				Kprim[(3*j+2)*(3*epo->numNodes)+(3*i+1)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j]+2)+(3*i+1)];
				Kprim[(3*j+2)*(3*epo->numNodes)+(3*i+2)] = epo->matrixK[(3*epo->numNodes)*(3*epo->interNodes[j]+2)+(3*i+2)];
			}

			//set the modified matrix K for support surface nodes for which force is unknown
			for(int j = 0; j < (epo->numSuppNodes); j++){
				Kprim[((3*epo->numInterNodes)+(3*j))*(3*epo->numNodes)+(3*i)] = 0;
				Kprim[((3*epo->numInterNodes)+(3*j))*(3*epo->numNodes)+(3*i+1)] = 0;
				Kprim[((3*epo->numInterNodes)+(3*j))*(3*epo->numNodes)+(3*i+2)] = 0;

				Kprim[((3*epo->numInterNodes)+(3*j+1))*(3*epo->numNodes)+(3*i)] = 0;
				Kprim[((3*epo->numInterNodes)+(3*j+1))*(3*epo->numNodes)+(3*i+1)] = 0;
				Kprim[((3*epo->numInterNodes)+(3*j+1))*(3*epo->numNodes)+(3*i+2)] = 0;

				Kprim[((3*epo->numInterNodes)+(3*j+2))*(3*epo->numNodes)+(3*i)] = 0;
				Kprim[((3*epo->numInterNodes)+(3*j+2))*(3*epo->numNodes)+(3*i+1)] = 0;
				Kprim[((3*epo->numInterNodes)+(3*j+2))*(3*epo->numNodes)+(3*i+2)] = 0;
					
			}

			//support surface nodes (in this case the force is unknown and has coefficient -1 in new arrangement of matrix K)
			if(epo->supportSurfNodes[i] == 1){
				Kprim[((3*epo->numInterNodes)+(3*forcepos))*(3*epo->numNodes)+(3*i)] = -1;
				Kprim[((3*epo->numInterNodes)+(3*forcepos+1))*(3*epo->numNodes)+(3*i+1)] = -1;
				Kprim[((3*epo->numInterNodes)+(3*forcepos+2))*(3*epo->numNodes)+(3*i+2)] = -1;

				forcepos++;

				Fprim[3*i] = 0;
				Fprim[3*i+1] = 0;
				Fprim[3*i+2] = 0;
			}
			else{//contact nodes or interior nodes or free surface nodes are known forces
				Fprim[3*i] = epo->F[3*i];
				Fprim[3*i+1] = epo->F[3*i+1];
				Fprim[3*i+2] = epo->F[3*i+2];
			}

			//set the modified vector F (bring all the known terms of the equation to one side)
			for(int j = 0; j < epo->numNodes; j++){
				if(epo->mapStartIndices[3*j] != -1){// the known terms are the ones with known displacement: all nodes except interior
					Fprim[3*i] -= epo->matrixK[(3*j)*(3*epo->numNodes)+(3*i)] * epo->Q[3*j];
					Fprim[3*i] -= epo->matrixK[(3*j+1)*(3*epo->numNodes)+(3*i)] * epo->Q[3*j+1];
					Fprim[3*i] -= epo->matrixK[(3*j+2)*(3*epo->numNodes)+(3*i)] * epo->Q[3*j+2];

					Fprim[3*i+1] -= epo->matrixK[(3*j)*(3*epo->numNodes)+(3*i+1)] * epo->Q[3*j];
					Fprim[3*i+1] -= epo->matrixK[(3*j+1)*(3*epo->numNodes)+(3*i+1)] * epo->Q[3*j+1];
					Fprim[3*i+1] -= epo->matrixK[(3*j+2)*(3*epo->numNodes)+(3*i+1)] * epo->Q[3*j+2];

					Fprim[3*i+2] -= epo->matrixK[(3*j)*(3*epo->numNodes)+(3*i+2)] * epo->Q[3*j];
					Fprim[3*i+2] -= epo->matrixK[(3*j+1)*(3*epo->numNodes)+(3*i+2)] * epo->Q[3*j+1];
					Fprim[3*i+2] -= epo->matrixK[(3*j+2)*(3*epo->numNodes)+(3*i+2)] * epo->Q[3*j+2];
				}
			}
			
		}


		//solve the F'= K' * U' to find the interior displacement
		clapack::dgels_(&trans, &dimension, &variabledim, &nrhs, Kprim, &dimension, Fprim, &dimension, work, &lwork, &info);       

		//update the interior displacements
		for(int i = 0; i < epo->numInterNodes; i++){
			epo->Q[3*epo->interNodes[i]] = Fprim[3*i];
			epo->Q[3*epo->interNodes[i]+1] = Fprim[3*i+1];
			epo->Q[3*epo->interNodes[i]+2] = Fprim[3*i+2];
		}

		                                                                      
		//update force for support surface nodes 
		forcepos = epo->numInterNodes;
		for(int i = 0; i < epo->numNodes; i++){
			if(epo->supportSurfNodes[i] == 1){
				epo->F[3*i] = Fprim[3*forcepos];
				epo->F[3*i+1] = Fprim[3*forcepos+1];
				epo->F[3*i+2] = Fprim[3*forcepos+2];

				forcepos++;
			}
		}
				

		delete [] Fprim; delete [] Kprim;


		//compute the free surface displacement using fitted parameters
		epo->computeFreeSurfDisplacement(Qcalc, Lambda, Mu);
		//compute the displacement error
		epo->computeDisplacementError(Qcalc, iter);

		
		
	/*	sprintf(buf22,"%s%d.txt", "Force", iter);
		print(F, dimension, 1, buf22);
		sprintf(buf22,"%s%d.txt", "Displacement", iter);
		print(Q, dimension, 1, buf22);*/


		// Given the deformed tetmesh, update the mapping from tetmesh to framemesh
		// if ( iter == 0 ) 
		// computeDisplacement(Qcalc);


		
	//multiplying the decomposed matrix K with displacement vector
		
		HQ = new double[dimension];
		clapack::dgemm_(&trans, &trans, &dimension, &nrhs, &dimension, &alpha, matrixH, &dimension, epo->Q, &dimension, &beta, HQ, &dimension);
	
		JQ = new double[dimension];
		clapack::dgemm_(&trans, &trans, &dimension, &nrhs, &dimension, &alpha, matrixJ, &dimension, epo->Q, &dimension, &beta, JQ, &dimension);
		                     

		//building this format: || [HQ  JQ] [lambda  mu]^T  -  F || -> || A x - b ||
		A = new double[2*3*numUsedEqn];
		b = new double[3*numUsedEqn];
		int j = 0;

		for (int i = 0; i < epo->numNodes; i++){
			double weight=1.0;
		  
			if(epo->ISContactNode(i) != -1 ) { 
				weight = 1.0;  // static_cast<double>(numUsedEqn-supportSurfNodes.size()-numInterNodes);
			}	
			if(epo->supportSurfNodes[i] == 1){
				weight = 0.0;
			}
			if (epo->mapStartIndices[3*i] == -1){
				weight = 0.0;
			}
		  
		  // if ( weight > 0.1 ) cerr << i << " ";

			A[3*j] = weight * HQ[3*i];
			A[3*j+1] = weight * HQ[3*i+1];
			A[3*j+2] = weight * HQ[3*i+2];

			A[3*numUsedEqn + 3*j] = weight * JQ[3*i];
			A[3*numUsedEqn + 3*j+1] = weight * JQ[3*i+1];
			A[3*numUsedEqn + 3*j+2] = weight * JQ[3*i+2];

			b[3*j] = weight * epo->F[3*i];
			b[3*j+1] = weight * epo->F[3*i+1];
			b[3*j+2] = weight * epo->F[3*i+2];

			j++;
		}
                        
		/*
		std::ostringstream os;
		os << "matA_" << iter  << ".txt";  
		std::ofstream matAFile( os.str().c_str() );
		os.clear(); os.str("");
		os << "vecB_" << iter  << ".txt";  
		std::ofstream vecBFile( os.str().c_str() );
		for (int i = 0; i < j; i++){
		  matAFile << A[3*i] << " " << A[3*numUsedEqn+3*i] << endl;
		  matAFile << A[3*i+1] << " " << A[3*numUsedEqn+3*i+1] << endl;
		  matAFile << A[3*i+2] << " " << A[3*numUsedEqn+3*i+2] << endl;
		  vecBFile << b[3*i] << endl;
		  vecBFile << b[3*i+1] << endl;
		  vecBFile << b[3*i+2] << endl;
		}
		matAFile.close();
		vecBFile.close();
		*/
		
		delete [] HQ; delete [] JQ; 


		//solve the least square to find the elasticity parameters
		clapack::dgels_(&trans, &dim1, &dim2, &nrhs, A, &dim1, b, &dim1, work, &lwork, &info);

		cout<<"********************"<<endl;
		cout<<"Iteration: "<<iter<<endl<<endl;
		if (info == 0){//successful
			epo->lambda.push_back(b[0]);//Lambda
			epo->mu.push_back(b[1]);//Mu

			// Could use Estar to constrain the relationship
			// Lambda = -2.0 * Mu * (4.0*Mu + Estar)/( 4.0 * Mu + Estar );
			// Mu = 0.25 * (sqrt(4.0 * Lambda*Lambda  + Estar ) + 2 * Lambda + Estar);
			// if ( Mu < 0 ) {
			//   cerr << "Mu: " << Mu;
			//   Mu = 0.25 * (sqrt(4.0 * Lambda*Lambda  + Estar ) - 2 * Lambda + Estar);
			//   cerr << " corrected " << Mu << endl;
			// }
			// Ignore b[0] an set Lambda for a poisson ratio of 0.45
			// double poisson = 0.45;
			// Mu = Lambda*(1.0-2.0*poisson)/2/poisson; // does not work
			// Lambda = 2.0*Mu*poisson/(1.0-2*poisson);
			// does not work
			// double youngs = 26000;
			// Lambda = Mu*(youngs-2.0*Mu)/(3*Mu-youngs);
			/*
			double root = youngs*youngs+2.0*Lambda*youngs+9.0*Lambda*Lambda;
			if ( root >= 0.0 ) {
			  root = sqrt(root);
			  Mu = -youngs+3.0*Lambda + root;
			}
			*/
			

			double residual = 0;
			for(int i = dim2;i < dim1; i++)
				residual += b[i] * b[i];
			epo->residualsqrt.push_back(sqrt(residual));//residual square root
			
			cout<<"Lambda: "<<b[0]<<endl<<"Mu: "<<b[1]<<endl;
			cout<<"Square root of the residual sum of squares: "<<sqrt(residual)<<endl;
		}
		else  cout<<"Least square solution for Elastic Parameters could not be computed!"<<endl;
		cout<<"********************"<<endl;

		delete [] A;
		delete [] b;
		

	}//end of iterations                                                                                                            


	delete [] Qcalc;

}

void ElasticParameterOptimization::LinearLameOpt::computeLocalMatrix_H_J(double *& localH, double *& localJ, int tetrahedronId)
{
	if((tetrahedronId < 0) || (tetrahedronId >= epo->allTetrahedra.size())) return;
	int i, offset;
	double volume, mu, lambda, det;
	double  * matrixB, * helpMat;
	
	//a decomposition of matrix C
	double matrixF[]= {1,1,1,0,0,0,
	                   1,1,1,0,0,0,
			   1,1,1,0,0,0,
	                   0,0,0,0,0,0,
	                   0,0,0,0,0,0,
	                   0,0,0,0,0,0};//matrices are stored column major

	double matrixG[]= {2,0,0,0,0,0,
	                   0,2,0,0,0,0,
			   0,0,2,0,0,0,
	                   0,0,0,1,0,0,
	                   0,0,0,0,1,0,
	                   0,0,0,0,0,1};

	matrixB = new double[6*12];
	helpMat = new double[6*12];
	vector<double> x, y, z;

	for(i = 0; i < 12*12; i++) {localH[i] = 0; localJ[i] = 0;}

	//Compute the matrix B:
	x.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][0]]->coordinate().x());
	x.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][1]]->coordinate().x());
	x.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][2]]->coordinate().x());
	x.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][3]]->coordinate().x());

	y.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][0]]->coordinate().y());
	y.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][1]]->coordinate().y());
	y.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][2]]->coordinate().y());
	y.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][3]]->coordinate().y());

	z.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][0]]->coordinate().z());
	z.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][1]]->coordinate().z());
	z.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][2]]->coordinate().z());
	z.push_back(epo->allNodes[epo->allTetrahedra[tetrahedronId][3]]->coordinate().z());

	//1. Compute the volume
	for(i = 0; i < 6*12; i++) helpMat[i] = 0;
	helpMat[0] = helpMat[4] = helpMat[8] = helpMat[12] = 1.0;
	helpMat[1] = x[0]; helpMat[2] = y[0]; helpMat[3] = z[0];
	helpMat[5] = x[1]; helpMat[6] = y[1]; helpMat[7] = z[1];
	helpMat[9] = x[2]; helpMat[10] = y[2]; helpMat[11] = z[2];
	helpMat[13] = x[3]; helpMat[14] = y[3]; helpMat[15] = z[3];

	volume = epo->computeDeterminant(helpMat, 4) / 6.0;

	//If the volume is zero, just give zero back (no need to compute everything since it will be multiplied by zero in the end anyways)
	if(volume == 0)
	{
		for(i = 0; i < 12*12; i++) {localH[i] = 0; localJ[i] = 0;}
		
		delete [] matrixB;
		delete [] helpMat;
	}

	else
	{
		//2. Fill the matrix
		for(i = 0; i < 6*12; i++) matrixB[i] = 0;

		//b1
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[1]; helpMat[2] = z[1]; helpMat[4] = y[2]; helpMat[5] = z[2]; helpMat[7] = y[3]; helpMat[8] = z[3];
		det = -epo->computeDeterminant(helpMat, 3);
		matrixB[0] = matrixB[9] = matrixB[17] = det;
		//c1
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[1]; helpMat[2] = z[1]; helpMat[4] = x[2]; helpMat[5] = z[2]; helpMat[7] = x[3]; helpMat[8] = z[3];
		det = epo->computeDeterminant(helpMat, 3);
		matrixB[3] = matrixB[7] = matrixB[16] = det;
		//d1
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[1]; helpMat[2] = y[1]; helpMat[4] = x[2]; helpMat[5] = y[2]; helpMat[7] = x[3]; helpMat[8] = y[3];
		det = -epo->computeDeterminant(helpMat, 3);
		matrixB[5] = matrixB[10] = matrixB[14] = det;
		
		//b2
		offset = 18;
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[2]; helpMat[2] = z[2]; helpMat[4] = y[3]; helpMat[5] = z[3]; helpMat[7] = y[0]; helpMat[8] = z[0];
		det = epo->computeDeterminant(helpMat, 3);
		matrixB[offset+0] = matrixB[offset+9] = matrixB[offset+17] = det;
		//c2
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[2]; helpMat[2] = z[2]; helpMat[4] = x[3]; helpMat[5] = z[3]; helpMat[7] = x[0]; helpMat[8] = z[0];
		det = -epo->computeDeterminant(helpMat, 3);
		matrixB[offset+3] = matrixB[offset+7] = matrixB[offset+16] = det;
		//d2
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[2]; helpMat[2] = y[2]; helpMat[4] = x[3]; helpMat[5] = y[3]; helpMat[7] = x[0]; helpMat[8] = y[0];
		det = epo->computeDeterminant(helpMat, 3);
		matrixB[offset+5] = matrixB[offset+10] = matrixB[offset+14] = det;

		//b3
		offset = 36;
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[3]; helpMat[2] = z[3]; helpMat[4] = y[0]; helpMat[5] = z[0]; helpMat[7] = y[1]; helpMat[8] = z[1];
		det = -epo->computeDeterminant(helpMat, 3);
		matrixB[offset+0] = matrixB[offset+9] = matrixB[offset+17] = det;
		//c3
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[3]; helpMat[2] = z[3]; helpMat[4] = x[0]; helpMat[5] = z[0]; helpMat[7] = x[1]; helpMat[8] = z[1];
		det = epo->computeDeterminant(helpMat, 3);
		matrixB[offset+3] = matrixB[offset+7] = matrixB[offset+16] = det;
		//d3
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[3]; helpMat[2] = y[3]; helpMat[4] = x[0]; helpMat[5] = y[0]; helpMat[7] = x[1]; helpMat[8] = y[1];
		det = -epo->computeDeterminant(helpMat, 3);
		matrixB[offset+5] = matrixB[offset+10] = matrixB[offset+14] = det;

		//b4
		offset = 54;
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = y[0]; helpMat[2] = z[0]; helpMat[4] = y[1]; helpMat[5] = z[1]; helpMat[7] = y[2]; helpMat[8] = z[2];
		det = epo->computeDeterminant(helpMat, 3);
		matrixB[offset+0] = matrixB[offset+9] = matrixB[offset+17] = det;
		//c4
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[0]; helpMat[2] = z[0]; helpMat[4] = x[1]; helpMat[5] = z[1]; helpMat[7] = x[2]; helpMat[8] = z[2];
		det = -epo->computeDeterminant(helpMat, 3);
		matrixB[offset+3] = matrixB[offset+7] = matrixB[offset+16] = det;
		//d4
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;
		helpMat[0] = helpMat[3] = helpMat[6] = 1.0;
		helpMat[1] = x[0]; helpMat[2] = y[0]; helpMat[4] = x[1]; helpMat[5] = y[1]; helpMat[7] = x[2]; helpMat[8] = y[2];
		det = epo->computeDeterminant(helpMat, 3);
		matrixB[offset+5] = matrixB[offset+10] = matrixB[offset+14] = det;

		for(i = 0; i < 6*12; i++) matrixB[i] = matrixB[i] / max((6.0*volume), THRESHOLD_DIV_ZERO);

		//Multiply the matrices:
		long int dim1, dim2;
		char transY, transN;
		double alpha, beta;
		transY = 'T';
		transN = 'N';
		dim1 = 6; 
		dim2 = 12;
		alpha = 1.0;
		beta = 0.0;

		for(i = 0; i < 6*12; i++) helpMat[i] = 0;

		clapack::dgemm_(&transY, &transN, &dim2, &dim1, &dim1, &alpha, matrixB, &dim1, matrixF, &dim1, &beta, helpMat, &dim2);
		clapack::dgemm_(&transN, &transN, &dim2, &dim2, &dim1, &alpha, helpMat, &dim2, matrixB, &dim1, &beta, localH, &dim2);

		for(i = 0; i < 12*12; i++) localH[i] *= volume; 
		for(i = 0; i < 6*12; i++) helpMat[i] = 0;

		clapack::dgemm_(&transY, &transN, &dim2, &dim1, &dim1, &alpha, matrixB, &dim1, matrixG, &dim1, &beta, helpMat, &dim2);
		clapack::dgemm_(&transN, &transN, &dim2, &dim2, &dim1, &alpha, helpMat, &dim2, matrixB, &dim1, &beta, localJ, &dim2);

		for(i = 0; i < 12*12; i++ ) localJ[i] *= volume; 

		delete [] matrixB;
		delete [] helpMat;
	}
}

void ElasticParameterOptimization::LinearLameOpt::computeMatrix_H_J(double *& matrixH, double *& matrixJ)
{
	int i, j, k, mappedJ, mappedK;

	if((epo->allNodes.numberOfItems() == 0) || (epo->allTetrahedra.size() == 0)) return;

	
	if (matrixH == NULL) matrixH = new double[3*(epo->numNodes) * 3*(epo->numNodes)];
	if (matrixJ == NULL) matrixJ = new double[3*(epo->numNodes) * 3*(epo->numNodes)];
	
	for(i = 0; i < 3*(epo->numNodes) * 3*(epo->numNodes); i++) {matrixH[i] = 0; matrixJ[i] = 0;}
	double * localH = new double[12*12];
	double * localJ = new double[12*12];

	for(i = 0; i < epo->allTetrahedra.size(); i++)
	{
		computeLocalMatrix_H_J(localH, localJ, i);


		for(j = 0; j < 4; j++)
		{
			mappedJ = epo->allTetrahedra[i][j];
			for(k = 0; k < 4; k++)
			{//k and mappedK are columns
				mappedK = epo->allTetrahedra[i][k];

				matrixH[(3*mappedK)*3*(epo->numNodes) + (3*mappedJ)] += localH[(3*k)*12 + (3*j)];
				matrixH[(3*mappedK)*3*(epo->numNodes) + (3*mappedJ+1)] += localH[(3*k)*12 + (3*j+1)];
				matrixH[(3*mappedK)*3*(epo->numNodes) + (3*mappedJ+2)] += localH[(3*k)*12 + (3*j+2)];
				
				matrixH[(3*mappedK+1)*3*(epo->numNodes) + (3*mappedJ)] += localH[(3*k+1)*12 + (3*j)];
				matrixH[(3*mappedK+1)*3*(epo->numNodes) + (3*mappedJ+1)] += localH[(3*k+1)*12 + (3*j+1)];
				matrixH[(3*mappedK+1)*3*(epo->numNodes) + (3*mappedJ+2)] += localH[(3*k+1)*12 + (3*j+2)];
				
				matrixH[(3*mappedK+2)*3*(epo->numNodes) + (3*mappedJ)] += localH[(3*k+2)*12 + (3*j)];
				matrixH[(3*mappedK+2)*3*(epo->numNodes) + (3*mappedJ+1)] += localH[(3*k+2)*12 + (3*j+1)];
				matrixH[(3*mappedK+2)*3*(epo->numNodes) + (3*mappedJ+2)] += localH[(3*k+2)*12 + (3*j+2)];



				matrixJ[(3*mappedK)*3*(epo->numNodes) + (3*mappedJ)] += localJ[(3*k)*12 + (3*j)];
				matrixJ[(3*mappedK)*3*(epo->numNodes) + (3*mappedJ+1)] += localJ[(3*k)*12 + (3*j+1)];
				matrixJ[(3*mappedK)*3*(epo->numNodes) + (3*mappedJ+2)] += localJ[(3*k)*12 + (3*j+2)];
				
				matrixJ[(3*mappedK+1)*3*(epo->numNodes) + (3*mappedJ)] += localJ[(3*k+1)*12 + (3*j)];
				matrixJ[(3*mappedK+1)*3*(epo->numNodes) + (3*mappedJ+1)] += localJ[(3*k+1)*12 + (3*j+1)];
				matrixJ[(3*mappedK+1)*3*(epo->numNodes) + (3*mappedJ+2)] += localJ[(3*k+1)*12 + (3*j+2)];
				
				matrixJ[(3*mappedK+2)*3*(epo->numNodes) + (3*mappedJ)] += localJ[(3*k+2)*12 + (3*j)];
				matrixJ[(3*mappedK+2)*3*(epo->numNodes) + (3*mappedJ+1)] += localJ[(3*k+2)*12 + (3*j+1)];
				matrixJ[(3*mappedK+2)*3*(epo->numNodes) + (3*mappedJ+2)] += localJ[(3*k+2)*12 + (3*j+2)];
			}
		}
	}
	delete [] localH;
	delete [] localJ;
}





ElasticParameterOptimization::NonLinearLameOpt::NonLinearLameOpt(ElasticParameterOptimization * const EPO, int maxIt){

	epo = EPO;

	n = 2;
	start = new double[n];
	xmin = new double[n];
	step = new double[n];
	konvge = 1;

	kcount = maxIt;
	reqmin = 1.0E-02;
	
	//--------------------------------------------------
	//based on different values of poisson ratio, lame parameters are calculated and the one with least error is picked as initial value
	double *Qcalc = new double[3*(epo->numNodes)];
	double *Fcalc = new double[3*(epo->numNodes)];
	double * lame, * minlame, * previouslame;
	double poisson, error, errorD, errorF, minerror = 0, lambdaRange, muRange;
	previouslame = epo->computeReducedYoungsModulus(0.01);

	FILE * fp;
	fp = fopen("InitialLameParam.txt","w");
	fprintf(fp, "%s\n\n", "# Poisson   Lambda   Mu   Total_Error   Displacement_Error   Force_Error");

	cout<<endl;
	
	  //for(double i = 1.5; i < 10; i += 0.5){
	  //poisson = log(i) / (log(10.0) * 2.0);//building a tighter grid of poisson

	for(poisson = 0.05; poisson <= 0.45; poisson += 0.05){

	
		lame = epo->computeReducedYoungsModulus(poisson);


		epo->computeFreeSurfDisplacement(Qcalc, lame[0], lame[1]);
		errorD = epo->computeDisplacementError(Qcalc);
		errorF = 0;
		error = errorD;

#ifdef WITH_FORCE_ERROR
		epo->computeCalculatedForce(Fcalc, lame[0], lame[1]);
		errorF = epo->computeForceError(Fcalc);

		error = errorD + epo->d_Umax/epo->d_Fmax*errorF;
#endif

		fprintf(fp, "%2.10f    %2.10f    %2.10f    %2.10f    %2.10f    %2.10f\n", poisson, lame[0], lame[1], error, errorD, errorF);

		cout<<"Displacement error: "<<errorD<<endl<<"Force error: "<<errorF<<endl<<"Total error: "<<error<<endl;
		cout<<"Poisson: "<<poisson<<"   Lambda: "<<lame[0]<<"   Mu: "<<lame[1]<<endl;
		
		lambdaRange = fabs(lame[0] - previouslame[0]);cout<<"Lambda Range: "<<lambdaRange<<endl;
		muRange = fabs(lame[1] - previouslame[1]);cout<<"Mu Range: "<<muRange<<endl;

		//if(poisson == (log(1.5)/(log(10.0)*2.0)) || error < minerror){
		if(poisson == 0.05 || error < minerror){
			minerror = error;
			minlame = lame;
			minlambdaRange = lambdaRange;
			minmuRange = muRange;
			minpoisson = poisson;
		}
		
		previouslame = lame;


		cout<<endl;
	}
	

	fprintf(fp, "\n\nEstar: %2.10f", lame[2]);
	cout<<endl<<"Selected values: "<<endl<<"Poisson: "<<minpoisson<<"   Lambda: "<<minlame[0]<<"   Mu: "<<minlame[1]<<endl
		<<"Lambda Range: "<<minlambdaRange<<"   Mu Rang: "<<minmuRange<<endl;;
		
	step[0] = minlambdaRange ; 
	step[1] = minmuRange ;
	start[0] = minlame[0];
	start[1] = minlame[1];

	fclose(fp);
	delete [] Qcalc;
	delete [] Fcalc;
	//-------------------------------------


	cout<<endl<<"NONLINEAR PARAMETER OPTIMIZATION"<<endl;
	cout<<"--------------------------------"<<endl;
}

ElasticParameterOptimization::NonLinearLameOpt::~NonLinearLameOpt(){

	if (start != NULL) delete [] start;
	if (xmin != NULL) delete [] xmin;
	if (step != NULL) delete [] step;
	
}


void ElasticParameterOptimization::NonLinearLameOpt::computeLameParam(){
	
 
  g_epo = epo;

	nelmin(wrapFunctor, n, start, xmin, &ynewlo, reqmin, step, konvge, kcount, &icount, &numres, &ifault );


		if (ifault == 0){//successful
		cout<<"Lambda: "<<xmin[0]<<endl<<"Mu: "<<xmin[1]<<endl;
		cout<<"Minimized error: "<<ynewlo<<endl;
	}
	else  cout<<"Nonlinear solution for Elastic Parameters could not be computed!"<<endl;
	


}





ElasticParameterOptimization::NLMinimization::NLMinimization(ElasticParameterOptimization * const EPO){

	epo = EPO;
	iter = 0;
}

double ElasticParameterOptimization::NLMinimization::operator()(double * x){
	
  if ( x[0] <= 0.0 ) return 1e3*x[0]*x[0];

  if ( x[1] <= 0.0 ) return 1e3*x[1]*x[1];

	double *Qcalc = new double[3*(epo->numNodes)];
	double *Fcalc = new double[3*(epo->numNodes)];

	//compute the free surface displacement using fitted parameters
	epo->computeFreeSurfDisplacement(Qcalc, x[0], x[1]);
	//compute the displacement error
	double errorDisp = epo->computeDisplacementError(Qcalc, iter);
	double errorForce = 0;
	double error = errorDisp;

#ifdef WITH_FORCE_ERROR
	//compute force using fitted parameters and known displacements
	epo->computeCalculatedForce(Fcalc, x[0], x[1]);
	//compute the force error
	errorForce = epo->computeForceError(Fcalc);

	error = errorDisp + epo->d_Umax/epo->d_Fmax*errorForce;
#endif
	
	epo->lambda.push_back(x[0]);
	epo->mu.push_back(x[1]);
	epo->overallError.push_back(error);
	epo->overallErrorDisp.push_back(errorDisp);
	epo->overallErrorForce.push_back(errorForce);

	
	cout<<"********************"<<endl;
	cout<<"Iteration: "<<iter<<endl<<endl;
	cout<<"Lambda: "<<x[0]<<endl<<"Mu: "<<x[1]<<endl;
	cout<<"Displacement Error: "<<errorDisp<<endl;
	cout<<"Force Error: "<<errorForce<<endl;
	cout<<"Minimized error: "<<error<<endl;
	cout<<"********************"<<endl;
	
	delete [] Qcalc;
	delete [] Fcalc;
	iter++;
	return error;
	}
























